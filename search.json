[{"title":"增加相册页面","path":"/posts/55447/","content":"简介：\n\n<!-- more -->\n\n\n\n我想做一个相册，但是我不知道什么样的相册比较美观，于是参考了一些论坛和博客。\n\n首先是[Discourse](https://www.discourse.org/)的一款插件[Tiles Image Gallery](https://meta.discourse.org/t/tiles-image-gallery/81950)。\n\n然后是[Volantis](https://vlts.cc/v6/tag-plugins/#gallery)的gallery标签，[频率](https://pinlyu.com/album/landscape/)的博客以及[教程](https://pinlyu.com/posts/31/)，[RongJ](https://blog.shishuai.monster/gallery/jay-chou/)的博客。\n\n最后我决定结合使用下面这两款插件：\n\n- [Justified Gallery](https://miromannino.github.io/Justified-Gallery/lightboxes/)\n- [Fancybox](https://fancyapps.com/docs/ui/fancybox)\n\n使用方法(暂时)：\n\n1. 在博客中插入html格式的图片。\n\n2. 在浏览器中执行JS脚本。\n\n可获得效果：\n\n   ![image-20221212214254821](https://githubimages.pengfeima.cn/images/202212122142275.png)\n\n代码：\n\n比较完善的版本可以看这里：[风景 | 杂记 (shishuai.monster)](https://blog.shishuai.monster/gallery/landscape/)。\n\n```html\n<div id=\"mygallery\" >\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291216879.jpg\">\n        <img alt=\"Title 1\" src=\"https://githubimages.pengfeima.cn/images/202211291216879.jpg\"/>\n    </a>\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291217546.jpg\">\n        <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217546.jpg\"/>\n    </a>\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291217893.jpg\">\n        <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217893.jpg\"/>\n    </a>\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291217240.jpg\">\n        <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217240.jpg\"/>\n    </a>\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291216894.jpg\">\n        <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216894.jpg\"/>\n    </a>\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291217904.jpg\">\n        <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217904.jpg\"/>\n    </a>\n    <a href=\"https://githubimages.pengfeima.cn/images/202211291217670.jpg\">\n        <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217670.jpg\"/>\n    </a>\n</div>\n```\n\n```javascript\nstellar.jQuery(() => {\n  // 加载 Justified Gallery\n  var jstified_gallery_js = \"https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.js\";\n  stellar.loadScript(jstified_gallery_js).then(() => {\n    $(\"#mygallery\").justifiedGallery().on('jg.complete', function () {\n      // 绑定 Fancybox\n      // TODO: 选择器要修改。\n      Fancybox.bind(\"img\", {\n        groupAll: true,\n        hideScrollbar: false,\n        Thumbs: {\n          autoStart: false,\n        },\n        caption: function (fancybox, carousel, slide) {\n          return slide.$trigger.alt || null\n        }\n      });\n    });\n  });\n});\n```"},{"title":"在博客中插入音乐","path":"/posts/63539/","content":"前言Hexo 是一个快速、简洁且高效的博客框架，他能帮助我们生成静态网站，部署在云服务器或者云空间中。我希望静态网站的体积尽可能小，生成速度尽可能快，以便我们能够以最经济，最快捷的方式部署网站，因此不希望静态网站中包含图片、音频、视频等媒体文件，这些文件会以链接的形式出现在HTML文档中。如果是私有资源，那么我会将这些媒体文件存放在成本更低、管理更方便的云存储中，并辅之以CDN，使用户获得最快的访问速度。如果是公有资源，那么我们可以通过在浏览器上运行Javascript脚本，在用户浏览网站时临时获取这些媒体文件，更加节省了自己的存储、带宽资源。写一个Hexo插件如果静态网站只包含HTML、CSS、JS三种类型的文件，怎样才能加入播放音乐的功能呢？首先，我们要将音乐的海报、音频、歌词等文件的链接写入HTML文档中。以Hexo为例子，在写Markdown格式的文档时，可以加入一些标记，例如下面的`musicplayer`标记，Hexo会将这段文本交给`musicplayer`插件处理，通过正则匹配识别出两首歌的资源链接。```html audio='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.lrc' name='我记得' artist='赵雷' audio='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.lrc' name='我记得' artist='赵雷'```识别以后，这些数据会被写入HTML文本。```html<div musicplayer><div name='我记得' artist='赵雷' audio='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.lrc'></div><div name='我记得' artist='赵雷' audio='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/user/images-1/main/music/1974443814.lrc'></div></div>```完成这些工作的插件是JS代码写成的`ejs`文件，至此静态网页生成完毕。然后就是在用户浏览器上的工作了，JS脚本会在HTML文本中找到`musicplayer`这一元素，然后解析里面的数据，构建出一个音乐播放器。这一步一般都有现成的代码，我采用的`aplayer`播放器插件，效果如下。这一步要也要写JS代码才能调用别人写好的插件。插入音乐播放器获取音乐资源最后再来讲讲音乐资源怎么获取。前面讲过，第一种方法是将音乐资源存储在云端。我是通过下面这个脚本下载音乐，然后将文件上传到github获取外链。下载网易云音乐资源到本地 codeblock:true```python# 网易云爬虫，使用了NeteaseCloudMusicApi，文档参见：# https://neteasecloudmusicapi.vercel.appimport requestsfrom loguru import loggerlogger.add('my_log.log')url_base = \"https://netease.user.cn\"class NeteaseAPI(): def song_lyric(self, id = '436147423'): url = url_base + \"/lyric\" params = { 'id':id } response = requests.get(url,params=params) logger.info(\"response.url: {}\".format(response.url)) return response def song_detail(self, id = '436147423'): url = url_base + \"/song/detail\" params = { 'ids':id } response = requests.get(url,params=params) logger.info(\"response.url: {}\".format(response.url)) return response def song(self, id = '436147423', level = 'standard'): # url = url_base + \"/song/url\" # old API url = url_base + \"/song/url/v1\" params = { 'id' : id, 'level' : level # standard => 标准 # higher => 较高 # exhigh => 极高 # lossless => 无损 # hires => Hi-Res } response = requests.get(url,params=params) logger.info(\"response.url: {}\".format(response.url)) return response def song_download(self, id = '1834270728', level = 'standard', filename = \"filename\"): result = self.song(id=id,level=level) url_song =  result.json()['data'][0]['url'] logger.info(\"url_song: {}\".format(url_song)) logger.info(\"song_path: {}\".format(filename)) # 判断歌曲是否能下载 if url_song == None : appendix = \".txt\" with open(filename + appendix, 'wb') as f: f.write(filename.encode()) else : appendix = '.' + url_song.split(\".\")[-1] response = requests.get(url_song) # 文件名外部传入，后缀从url解析 with open(filename + appendix, 'wb') as f: f.write(response.content) logger.info(\"response.url: {}\".format(response.url)) return filename + appendix# test NA = NeteaseAPI()id=\"453927771\"# 获取歌曲详细信息result = NA.song_detail(id=id)song_name = result.json()['songs'][0]['name']singer_name = result.json()['songs'][0]['ar'][0]['name']with open(\"-\".join([id,song_name,singer_name])+'.txt', 'wb') as f: f.write(result.content)# 获取歌曲封面response = requests.get(result.json()['songs'][0]['al']['picUrl'])with open(id+'.png', 'wb') as f: f.write(response.content)# 获取歌词result = NA.song_lyric(id=id)with open(id+'.lrc', 'w') as f: f.write(result.json()['lrc']['lyric'])# 获取歌曲音频result = NA.song_download(id=id,filename=id)# 返回我们需要的格式url_base = \"https://raw.githubusercontent.com/user/images-1/main/music/\"print(\"audio=\\'\"+url_base+id+\".mp3\\',\")print(\"cover=\\'\"+url_base+id+\".png\\',\")print(\"lrc=\\'\"+url_base+id+\".lrc\\',\")print(\"name=\\'\"+song_name+'\\',')print(\"artist=\\'\"+singer_name+'\\',')```第二种方法就是直接从网易云音乐的服务器获取，这中间需要通过vercel搭建自己的API服务。以下JS代码可以根据音乐的id号，从网易云音乐的服务器获取专辑封面、歌词、音频。其中，VIP歌曲也可以获取，但是少数歌曲只能试听30秒，我也不知道原因。在浏览器中获取网易云音乐资源 codeblock:true```javascript// 要确保已经引入了https://unpkg.com/flyio/dist/umd/fly.umd.min.js文件var fly=new Fly();url_base = \"https://netease.user.cn\"const NeteaseMusicAPI = { download_lyric: async(id) => { console.log('Downloading lyric...', id) url = url_base + \"/lyric\" params = { 'id':id } // 成功的回调函数 function download_lyric_success(result) { console.log(\"Downloaded successfully.\"); return result; } // 失败的回调函数 function download_lyric_fail(error) { console.log(\"Failed to download.\" + error); } let result = fly.request(url, params).then(download_lyric_success,download_lyric_fail); let data = await result.then((result) => {return result['data']['lrc']['lyric']}); return data; }, download_song_detail: async(id) => { url = url_base + \"/song/detail\" params = { 'ids':id } let result = fly.request(url, params).then( (result) => { console.log(\"Downloaded successfully.\"); console.log(result['data']['songs'][0]['name']); console.log(result['data']['songs'][0]['ar'][0]['name']); console.log(result['data']['songs'][0]['al']['picUrl']); var details = {}; details['name'] = result['data']['songs'][0]['name']; details['singer'] = result['data']['songs'][0]['ar'][0]['name']; details['pic'] = result['data']['songs'][0]['al']['picUrl']; return details; }, (error) => { console.log(\"Failed to download. The error is : \" + error); return result; }); return result; }, download_song_url: (id, level = 'standard') => { url = url_base + \"/song/url/v1\" params = { 'id' : id, 'level' : level } let result = fly.request(url, params).then( (result) => { console.log(\"Downloaded successfully.\"); url = result['data']['data'][0]['url']; // 删除 https:// 或者 http:// url = url.replace(/^(httphttps):/, ''); console.log(url); return url; }, (error) => { console.log(\"Failed to download. The error is : \" + error); return result; }); return result; }, layoutDiv: (cfg) => { const el = $(cfg.el)[0]; var id = cfg.song_id; var lyric = NeteaseMusicAPI.download_lyric(id); var detail = NeteaseMusicAPI.download_song_detail(id); var url = NeteaseMusicAPI.download_song_url(id); url.then((song_url)=>{ var cell = '<audio src=\\\"' + song_url + '\\\" controls></audio>'+''; $(el).append(cell); }); detail.then((details)=>{ var cell = '歌名'+details['name']+''+''; cell += '歌手'+details['singer']+''+''; cell += '<img src=\\\"' + details['pic'] + '\\\"></img>'+''+''+''; $(el).append(cell); }); lyric.then((lyric)=>{ var cell = lyric+''+''; $(el).append(cell); }); },}// DOM 的解析// <div class='netease-music-player' song_id='436147423'>// <div class='netease-music-player'>// <div song_id='436147423'></div>// <div song_id='436147423'></div>// </div>$(function () { const els = document.getElementsByClassName('netease-music-player'); console.log(\"netease-music-player\"); console.log(\"els.length\",els.length); for (var i = 0; i < els.length; i++) { console.log(\"netease-music-player\"); const el = els[i]; const song_id = el.getAttribute('song_id'); if (song_id == null) { continue; } var cfg = new Object(); cfg.el = el; cfg.song_id = song_id; NeteaseMusicAPI.layoutDiv(cfg); }});```本文涉及到的代码我肝了一下午，读懂这些代码需要知道Promise的用法，异步计算，如何用vercel搭建网易云音乐的第三方API服务器。以下是一些参考资料：- 文档对象模型(Document_Object_Model, DOM)- 使用Promise- async 函数示例以下给出四个例子，音乐播放器可以通过hexo标签放置，也可以通过HTML代码放置，两者等价。网易云音乐资源只需插入网易云音乐编号，会自动获取音频等资源的链接。 HTML 方式```html<div class=\"stellar-musicplayer\" id=\"aplayer1\" from='netease' song_id='436147423,1309394503,26590191'></div>``` 效果<div class=\"stellar-musicplayer\" id=\"aplayer1\" from='netease' song_id='436147423,1309394503,26590191'></div> hexo 插件的方式`````` 效果自己云存储中的音乐资源 HTML 方式```html<div class=\"stellar-musicplayer\" id=\"aplayer3\" from='local'><div url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927771.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927771.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927771.lrc' name='喜欢' artist='张悬'  ></div><div url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/29818028.mp3' cover='http://qiniu.pengfeima.cn/typora/202212062310206.jpg' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/29818028.lrc' name='Rainy Mood' artist='www.rainymood.com'  ></div><div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1309394503.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1309394503.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1309394503.lrc' name='The White Lady' artist='Christopher Larkin' ></div> <div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.lrc' name='我记得' artist='赵雷'  ></div><div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927794.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927794.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927794.lrc' name='如何' artist='张悬'  ></div><div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.lrc' name='留下来陪你生活' artist='张悬'  ></div></div>``` 效果<div class=\"stellar-musicplayer\" id=\"aplayer3\" from='local'><div url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927771.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927771.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927771.lrc' name='喜欢' artist='张悬'  ></div><div url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/29818028.mp3' cover='http://qiniu.pengfeima.cn/typora/202212062310206.jpg' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/29818028.lrc' name='Rainy Mood' artist='www.rainymood.com'  ></div><div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1309394503.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1309394503.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1309394503.lrc' name='The White Lady' artist='Christopher Larkin' ></div> <div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.lrc' name='我记得' artist='赵雷'  ></div><div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927794.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927794.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/453927794.lrc' name='如何' artist='张悬'  ></div><div  url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.lrc' name='留下来陪你生活' artist='张悬'  ></div></div> hexo 插件的方式```url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.lrc' name='我记得' artist='赵雷'url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.lrc' name='留下来陪你生活' artist='张悬'``` 效果url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/1974443814.lrc' name='我记得' artist='赵雷'url='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.mp3' cover='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.png' lrc='https://raw.githubusercontent.com/shaoyaoqian/images-1/main/music/26590191.lrc' name='留下来陪你生活' artist='张悬'","tags":["音乐播放器"]},{"title":"过年了放烟花啦","path":"/posts/12076/","content":"非常棒的烟花模拟器！稍等片刻，烟花盛宴马上开始，将会有十一种烟花照亮天空！\n\n<!-- more -->\n\n<iframe id=\"inlineFrameExample\"\n    title=\"Inline Frame Example\"\n    width=100%\n    height=800px\n    style=\"border: medium none\"\n    src=\"https://nianbroken.github.io/Firework_Simulator/\">\n</iframe>\n\n源码来自[Firework_Simulator](https://github.com/NianBroken/Firework_Simulator) ，原作者为 [XgpNwb](https://codepen.io/MillerTime/pen/XgpNwb)，你也可以[全屏观看](https://nianbroken.github.io/Firework_Simulator/)。"},{"title":"浸没边界有限元方法的无条件能量稳定格式","path":"/posts/47559/","content":"简介：\n\n<!-- more -->\n大概就是这样：给出一种数值格式，证明它无条件能量稳定，然后再设计求解算法，最后实现CPU-GPU异构并行。\n大概就是这样：给出一种数值格式，证明它无条件能量稳定，然后再设计求解算法，最后实现CPU-GPU异构并行。\n\n\n\nWe will show stability for a wide class of spatial discretizations but only for two types of temporal discretizations. We analyze unsteady Stokes flow because as mentioned above, the advection terms of the Navier–Stokes equations are not the cause of instability in these methods. We will, however, include the advection terms in some computational tests in Section 5.\n\n我们这样做是因为时间离散化的选择似乎比空间离散化对稳定性更重要——我们将显示出广泛的空间离散化类别的稳定性，但仅适用于两种类型的时间离散化。我们分析非定常斯托克斯流，因为如上所述，Navier-Stokes方程的平流项不是这些方法中不稳定的原因。然而，我们将在第5节的一些计算测试中包括平流项。\n\n#### 时间离散\n\n不管是经典的浸没边界法，还是它的拓展模型，在数值格式的稳定性方面，时间离散格式都比空间离散格式更重要。本文所讨论的模型也不例外。因此，我们首先将连续运动方程按时间变量进行离散，得到一个空间连续、时间离散的系统。公式 (1-5) 是本文使用的时间离散格式，它的特点是固体位移方程 (5) 采用了隐式离散。此外，插值算子和延拓算子中的固体位移变量采用了显式离散，由此产生的迟滞效应并不会影响数值格式的稳定性。\n$$\n\\begin{equation}\n            \\rho\\left(\\frac{\\mathbf{u}_{n+1}-{\\mathbf{u}_{n}}}{\\Delta t}+{\\color{red}\\mathbf{u}_{n}} \\cdot \\nabla \\mathbf{u}_{n+1}\\right)-\\mu \\Delta \\mathbf{u}_{n+1}+\\nabla p_{n+1} = \\mathbf{f}_{n+1},\n        \\end{equation}\n$$\n$$\n\\begin{equation}\n            \\nabla \\cdot \\mathbf{u}_{n+1} =0, \n\\end{equation}\n$$\n$$\n\\begin{equation}\n            \\int_{B_{r}} \\mathbf{F}_{n+1} \\cdot \\mathbf{V} \\mathrm d \\mathbf{x} =-\\int_{B_{r}} \\mathbb{P}_{n+1}: \\nabla \\mathbf{V} \\mathrm d \\mathbf{X},\n        \\end{equation}\n$$\n$$\n        \\begin{equation}\n            \\mathbf{f}\\left(\\mathbf{x}, t_{n+1}\\right) =\\int_{B_r} \\mathbf{F}\\left(\\mathcal{X}_{n+1}\\right) \\delta\\left(\\mathbf{x}-{\\color{red}\\mathcal{X}_{n}}\\right) \\mathrm d \\mathbf{X} ,\n        \\end{equation}\n$$\n$$\n\\begin{equation}\n            \\frac{\\mathcal{X}\\left(\\mathbf{X}, t_{n+1}\\right) - \\mathcal{X}\\left(\\mathbf{X}, t_{n}\\right)}{\\Delta t} =  \\int_{\\Omega} {\\color{red}\\mathbf{u}\\left(\\mathbf{x}, t_{n+1}\\right)} \\delta\\left(\\mathbf{x}-{\\color{red}\\mathcal{X}_{n}}\\right) \\mathrm d \\mathbf{x}.\n        \\end{equation}\n$$\n\n\n\n#### 半离散格式的无条件能量稳定证明\n\n我们将为流固耦合系统定义一个适当的能量函数，并证明在满足某些条件的情况下，它是一个关于时间非增的函数，因此也是一个有界函数。这就证明了数值格式 (1-5) 是无条件稳定的。\n\n令$(\\mathbf{v},\\mathbf{w})_{\\Omega}=\\int_{\\Omega}\\mathbf{v}\\cdot\\mathbf{w}\\;\\mathrm{d}\\mathbf{x}$表示$L^2(\\Omega)$的内积，$\\|\\cdot\\|_{L^2(\\Omega)}$表示$L^2(\\Omega)$的范数，$\\frac{\\rho}{2}\\|\\mathbf{u}\\|_{L^2(\\Omega)}^2$为流固耦合系统的总动能。令$(\\mathbf{V},\\mathbf{W})_{B_r}=\\int_{B_r}\\mathbf{V}\\cdot\\mathbf{W}\\;\\mathrm{d}\\mathbf{X}$表示$L^2(B_r)$的内积，$E(\\mathcal{X})=\\int_{B_r}W(\\mathcal{X})\\;\\mathrm{d}\\mathbf{X}$表示固体的弹性势能。流固耦合系统的总能量是流固耦合系统的总动能和固体的弹性势能之和，是一个关于$\\mathbf{u}$和$\\mathcal{X}$的函数，可以表示成\n\n$$\nR(\\mathbf{u},\\mathcal{X})=\\frac{\\rho}{2}\\|\\mathbf{u}\\|_{L^2(\\Omega)}^2+E(\\mathcal{X})\n$$\n\n\n将等式(1)和 $\\mathbf{u}_{n+1}$ 在 $\\Omega$ 上做内积，~~将等式(2)和 $\\mathbf{p}_{n+1}$ 在 $\\Omega$ 上做内积（这一条好像没有必要），~~将 $\\mathbf{V} = \\frac{1}{\\Delta t}(\\mathcal{X}_{n+1}-\\mathcal{X}_{n})$ 代入等式(3)，将等式(4)和 $\\mathbf{u}_{n+1}$ 在 $\\Omega$ 上做内积，将等式(5)和 $-\\mathbf{F}_{n+1}$ 在 $B_r$ 上做内积，我们可以得到方程组(7-11)。\n\n$$\n\\begin{equation}\n        \\begin{aligned}\n            \\frac{\\rho}{\\Delta t}\\left(\\mathbf{u}_{n+1}-\\mathbf{u}_n,\\mathbf{u}_{n+1}\\right)_{\\Omega}&+\\left(\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}\n            -\\mu\\left(\\Delta\\mathbf{u}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}\\\\\n&-\\left(\\nabla p_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}=\\left(\\mathbf{f}_{n+1}\\cdot\\mathbf{u}_{n+1}\\right)_{\\Omega}\n        \\end{aligned}\n    \\end{equation}\n$$\n$$\n    \\begin{equation}\n    \\left(p_{n+1},\\nabla\\cdot\\mathbf{u}_{n+1}\\right)=0\n    \\end{equation}\n$$\n$$\n\\begin{equation}\n        \\frac{1}{\\Delta t}\\left(\\mathbf{F}_{n+1},\\mathcal{X}_{n+1}-\\mathcal{X}_{n}\\right)_{B_r}=-\\frac{1}{\\Delta t}(\\mathbb{P}_{n+1},\\nabla(\\mathcal{X}_{n+1}-\\mathcal{X}_{n}))_{B_r}\n    \\end{equation}\n$$\n\n$$\n\\begin{equation} \\left(\\mathbf{f}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}=\\int_{\\Omega}\\int_{B_r}\\mathbf{F}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{X}\\cdot\\mathbf{u}_{n+1}\\;\\mathrm{d}\\mathbf{x}\n    \\end{equation}\n$$\n\n$$\n\\begin{equation}\n        -\\frac{1}{\\Delta t}\\left((\\mathcal{X}_{n+1}-\\mathcal{X}_{n}),\\mathbf{F}_{n+1}\\right)_{B_r}=-\\int_{B_r}\\int_\\Omega\\mathbf{u}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{x}\\cdot\\mathbf{F}_{n+1}\\;\\mathrm{d}\\mathbf{X}\n\\end{equation}\n$$\n\n不失一般性，我们假设速度满足边界条件$\\mathbf{u}|_{\\partial \\Omega}=0$或$\\frac{\\partial\\mathbf{u}}{\\partial \\mathbf{n}}|_{\\partial\\Omega}=0$，根据无散度条件$\\nabla\\cdot\\mathbf{u}_{n+1}=0$，我们可以得出 $\\left(\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}=0$，且$\\left(\\nabla p_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}=0$。此外，我们假设应变能函数以下条件：\n\n令$\\mathbb{H}$为对 $W$ 二阶求导得到的四阶张量：\n\n$$\n        \\mathbb{H}_{\\alpha i \\beta j}:=\\frac{\\partial^2 W}{\\partial \\mathbb{F}_{\\alpha i} \\partial \\mathbb{F}_{\\beta j}} \\text {. }\n$$\n假设存在$\\kappa_{\\min },\\kappa_{\\max }>0$使得\n$$\n        \\kappa_{\\min } \\mathbb{E}^2 \\leqslant \\mathbb{E}: \\mathbb{H}: \\mathbb{E} \\leqslant \\kappa_{\\max } \\mathbb{E}^2\n$$\n对任意二阶张量$\\mathbb{E}$成立。其中， $\\mathbb{E}^2=\\mathbb{E}: \\mathbb{E}, \\quad \\mathbb{E}: \\mathbb{H}: \\mathbb{E}=\\mathbb{E}_{\\alpha i} \\mathbb{H}_{\\alpha i \\beta j} \\mathbb{E}_{\\beta j}$。\n\n对于不可压缩材料，这是一个合理的假设，据此可以得出\n$$\n\\frac{1}{\\Delta t}\\left(E\\left(\\mathcal{X}^{n+1}\\right)-E\\left(\\mathcal{X}^n\\right)\\right)\\le\\left(\\mathbb{P}\\left(\\mathbb{F}^{n+1}\\right), \\frac{\\mathbb{F}^{n+1}-\\mathbb{F}^n}{\\Delta t}\\right)_{\\mathcal{B}}\n$$\n对于等式(7)中的第一项，我们可以进行如下推导：\n$$\n\\begin{equation}\n        (\\mathbf{u}_{n+1}-\\mathbf{u}_n,\\mathbf{u}_{n+1})=\\frac{1}{2}\\|\\mathbf{u}_{n+1}-\\mathbf{u}_n\\|_{\\Omega}^2+\\frac{1}{2}(\\|\\mathbf{u}_{n+1}\\|_{\\Omega}^2-\\|\\mathbf{u}_{n}\\|_{\\Omega}^2)\n    \\end{equation}\n$$\n\n而对于等式(10)和(11)中插值算子和延拓算子，我们可以通过交换积分顺序得到等式(16)\n$$\n\\begin{equation}\n        \\int_{\\Omega}\\int_{B_r}\\mathbf{F}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{X}\\cdot\\mathbf{u}_{n+1}\\;\\mathrm{d}\\mathbf{x} = \\int_{B_r}\\int_\\Omega\\mathbf{u}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{x}\\cdot\\mathbf{F}_{n+1}\\;\\mathrm{d}\\mathbf{X}\n    \\end{equation}\n$$\n\n最后，将(15)代入(7)，将(16)代入(10)，再将(7)(9)(10)(11)式相加，可以得到等式\n$$\n\\begin{equation}\n        \\frac{\\rho}{2\\Delta t}\\left(\\|\\mathbf{u}_{n+1}\\|^2-\\|\\mathbf{u}_{n}\\|^2\\right)+\\frac{1}{\\Delta t}\\left(E(\\mathcal{X}^{n+1})-E(\\mathcal{X}^n)\\right)=\\mu\\left(\\Delta\\mathbf{u}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega}-\\frac{\\rho}{2\\Delta t}(\\|\\mathbf{u}_{n+1}\\|_{\\Omega}^2-\\|\\mathbf{u}_{n}\\|_{\\Omega}^2)\n    \\end{equation}\n$$\n\n因此方程组(1-5)求解出来的$\\mathbf{u}$和$\\mathcal{X}$满足不等式\n\n$$\nR(\\mathbf{u},\\mathcal{X})_{n+1}-R(\\mathbf{u},\\mathcal{X})_{n}\\le0\n$$\n\n因此半离散格式的无条件能量稳定的。在$\\mathbf{u}_{n+1}$和$\\mathcal{X}_{n+1}$可解的前提下，取任意大的时间步长，系统都是稳定的。\n\n#### 全离散\n\n全离散格式的证明是类似的，但是这里有个问题我纠结了很久。如果速度和压强整体求解$(\\mathbf{u}_{n+1},p_{n+1})$，那么全离散格式仍是无条件能量稳定的，但是计算效率并不高。如果采用投影方法，先求一个中间速度$\\mathbf{u}_*$，再求解压强$p_{n+1}$，最后求解速度$\\mathbf{u}_{n+1}$，求解效率固然高，但是对流项只能采用$\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_*$，不能采用$\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_{n+1}$，因此证明不了全离散格式的无条件稳定。\n\n在浸没边界法中，对流项是影响稳定性的次要因素，Newren论文中是这样说的：因为对流项对稳定性影响不大，我们只考虑没有对流项的Stokes方程。Boffi的论文中是这样说的：假设我们能精确估计出对流项$\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_{n+1}$。\n\n我这里的证明暂时先不考虑对流项，离散格式如下：\n\n\n$$\n\\begin{equation}\n\\frac{\\rho}{\\Delta t}\\left(\\mathbf{u}_{*}-{\\mathbf{u}_{n}}\\right)-\\mu \\Delta_h \\mathbf{u}_{*} = \\mathbf{f}_{n+1},\n\\end{equation}\n$$\n$$\n\\begin{equation}\n\\Delta^h p_{n+1}=\\frac{1}{\\Delta t} \\nabla^h \\cdot \\mathbf{u}^*\n\\end{equation}\n$$\n$$\n\\begin{equation}\n\\mathbf{u}^{n+1}=\\mathbf{u}^*-\\Delta t \\nabla^h p_{n+1}\n\\end{equation}\n$$\n$$\n\\begin{equation}\n            \\int_{B_{h}} \\mathbf{F}_{h,n+1} \\cdot \\mathbf{V}_h \\mathrm d \\mathbf{x} =\\int_{B_h} \\mathbb{P}_{h,n+1}: \\nabla \\mathbf{V}_h \\mathrm d \\mathbf{X},\n        \\end{equation}\n$$\n$$\n\\begin{equation}\n            \\mathbf{f}\\left(\\mathbf{x}, t_{n+1}\\right) =\\int_{B_r} \\mathbf{F}_{h,n+1} \\delta\\left(\\mathbf{x}-{\\color{red}\\mathcal{X}_{h,n}}\\right) \\mathrm d \\mathbf{X} ,\n        \\end{equation}\n$$\n$$\n\\begin{equation}\n            \\frac{\\mathcal{X}_{h,n+1} - \\mathcal{X}_{h,n}}{\\Delta t} =  \\int_{\\Omega} {\\color{red}\\mathbf{u}_{n+1}} \\delta\\left(\\mathbf{x}-{\\color{red}\\mathcal{X}_{h,n}}\\right) \\mathrm d \\mathbf{x}.\n        \\end{equation}\n$$\n\n#### 内积形式\n\n空间离散后，内积需要重新定义：$(\\mathbf{v},\\mathbf{w})_{\\Omega_h}=\\sum_{i j} \\mathbf{v}_{i j} \\cdot \\mathbf{w}_{i j} \\Delta x \\Delta y$。\n\n参考构型上的内积差别不大：$(\\mathbf{V},\\mathbf{W})_{B_h}=\\int_{B_h}\\mathbf{V}\\cdot\\mathbf{W}\\mathrm{d}\\mathbf{x}$。\n\n- 将等式(17)和 $\\mathbf{u}_{n+1}$ 在 $\\Omega_h$ 上做内积\n- 将等式(19)和 $\\mathbf{u}_{n+1}$ 在 $\\Omega_h$ 上做内积\n\n- 将 $\\mathbf{V}_h = \\frac{1}{\\Delta t}(\\mathcal{X}_{h,n+1}-\\mathcal{X}_{h,n})$ 代入等式(3)\n\n- 将等式(4)和 $\\mathbf{u}_{n+1}$ 在 $\\Omega_h$ 上做内积\n\n- 将等式(5)和 $-\\mathbf{F}_{h,n+1}$ 在 $B_h$ 上做内积\n\n$$\n\\begin{equation}\n        \\begin{aligned}\n            \\frac{\\rho}{\\Delta t}\\left(\\mathbf{u}_{*}-\\mathbf{u}_n,\\mathbf{u}_{n+1}\\right)_{\\Omega_h}\n            -\\mu\\left(\\Delta\\mathbf{u}_{*},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}=\\left(\\mathbf{f}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}\n        \\end{aligned}\n    \\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left(\\mathbf{u}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}=(\\mathbf{u}_*-\\Delta t \\nabla^h p_{n+1},\\mathbf{u}_{n+1})_{\\Omega_h}\n    \\end{equation}\n$$\n\n$$\n\\begin{equation}\n        \\frac{1}{\\Delta t}\\left(\\mathbf{F}_{h,n+1},\\mathcal{X}_{h,n+1}-\\mathcal{X}_{h,n}\\right)_{B_h}=(\\mathbb{P}_{h,n+1},\\nabla(\\mathcal{X}_{h,n+1}-\\mathcal{X}_{h,n}))_{B_h}\n    \\end{equation}\n$$\n\n$$\n\\begin{equation} \\left(\\mathbf{f}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}=\\left(\\int_{B_r}\\mathbf{F}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{X},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}\n    \\end{equation}\n$$\n\n$$\n\\begin{equation}\n        -\\frac{1}{\\Delta t}\\left((\\mathcal{X}_{n+1}-\\mathcal{X}_{n}),\\mathbf{F}_{n+1}\\right)_{B_h}=\\left(\\int_\\Omega\\mathbf{u}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{x},\\mathbf{F}_{n+1}\\right)_{B_h}\n\\end{equation}\n$$\n\n#### 假设条件\n\n1. 离散算子$\\nabla^h$和$\\Delta^h$满足可交换性。\n\n2. 适当的边界条件使得离散的无散度向量场与离散的梯度场的内积为零。$\\left(\\mathbf{u},\\nabla^h p\\right)_{\\Omega_h}=0$。\n\n3. 应变能函数满足前文所述假设。\n\n4. 插值算子和延拓算子满足（插值算子和延拓算子在空间离散后不一定满足对偶性）\n   $$\n   \\left(\\int_{B_r}\\mathbf{F}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{X},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}\\le\\left(\\int_\\Omega\\mathbf{u}_{n+1}\\delta(\\mathbf{x}-\\mathcal{X}_{n})\\;\\mathrm{d}\\mathbf{x},\\mathbf{F}_{n+1}\\right)_{B_h}\n   $$\n   \n\n#### 推导过程\n\n将(19)代入(24)消去$\\mathbf{u}_*$，其他和半离散格式类似。\n\n#### 因此前述全离散格式无条件稳定\n\n$$\n\\begin{equation}\n        \\frac{\\rho}{2\\Delta t}\\left(\\|\\mathbf{u}_{n+1}\\|^2-\\|\\mathbf{u}_{n}\\|^2\\right)+\\frac{1}{\\Delta t}\\left(E(\\mathcal{X}_{h,n+1})-E(\\mathcal{X}_{h,n})\\right)\\le\\mu\\left(\\Delta\\mathbf{u}_{n+1},\\mathbf{u}_{n+1}\\right)_{\\Omega_h}\n    \\end{equation}\n$$\n\n## 算法\n\n引入离散的插值算子和延拓算子后，全离散格式可以写成\n$$\n\\begin{gathered}\n\\frac{\\rho}{\\Delta t}\\left({\\mathbf{u}_{*}-\\mathbf{u}_n}\\right)-\\mu \\Delta \\mathbf{u}_{*}=\\mathbf{f}_{*} \\\\\n\\Delta^h p_{n+1}=\\frac{1}{\\Delta t} \\nabla^h \\cdot \\mathbf{u}^*\\\\\n\\mathbf{u}^{n+1}=\\mathbf{u}^*-\\Delta t \\nabla^h p_{n+1} \\\\\n\\int_{B_r} \\mathbf{F}_{n+1} \\cdot \\mathbf{V d} \\mathbf{x}=\\int_{B_r} \\mathbb{P}_{n+1}: \\nabla \\mathbf{V d} \\mathbf{X}, \\\\\n\\mathbf{f}\\left(\\mathbf{x}, t_{n+1}\\right)=\\mathcal{J}_{h, n}\\left(\\mathbf{F}_{n+1}\\right) \\\\\n\\mathbf{U}\\left(\\mathbf{X}, \\mathbf{t}_{\\mathbf{n}+\\mathbf{1}}\\right)=\\mathcal{S}_{h, n}\\left(\\mathbf{u}_{n+1}\\right)\n\\end{gathered}\n$$\n引入函数\n$$\nh_{n+1}\\left(\\mathcal{X}_{h,n+1}\\right)=\\frac{\\mathcal{X}_{h,n+1}-\\mathcal{X}_{h,n}}{\\Delta t}-\\mathbf{U}_{h,n+1}\n$$\n其中，$\\mathbf{U}_{h,n+1}$为关于$\\mathcal{X}_{h,n+1}$的非线形函数。为了简明符号，令$\\mathcal{X}$为$\\mathcal{X}_{h,n+1}$的系数构成的向量，即 $\\mathcal{X}=\\left\\{\\mathcal{X}_l(t_{n+1})\\right\\}_{l=1}^M$。我们采用迭代法求解方程(30)，即构造一组序列 $\\left\\{\\mathcal{X}_{n+1}^{(k)}\\right\\} $ 使得 $\\left\\|h_{n+1}\\left(\\mathcal{X}_{n+1}^{(k)}\\right)\\right\\|$趋于零。 \n\n### 牛顿方法\n\n求解 $\\mathbf{h}_{n+1}\\left(\\mathcal{X}_{n+1}\\right)=0$ 的 Newton 迭代公式为:\n$$\nh\\left(\\mathcal{X}_{n+1}^{(k)}\\right)+J\\left(\\mathcal{X}_{n+1}^{(k)}\\right)\\left(\\mathcal{X}_{n+1}^{(k+1)}-\\mathcal{X}_{n+1}^{(k)}\\right)=0\n$$\n其中 $J\\left(\\mathcal{X}_{n+1}^{(k)}\\right)$ 为 Jacobian 矩阵\n$$\nJ\\left(\\mathcal{X}_{n+1}^{(k)}\\right)=\\frac{\\partial h\\left(\\mathcal{X}_{n+1}^{(k)}\\right)}{\\partial \\mathcal{X}_{n+1}}\n$$\n但 $J\\left(\\mathcal{X}_{n+1}^{(k)}\\right)$ 的解析表达式难以获得。\n\n### 差分法求解Jacobian矩阵\n\nNewren 采用差分法求解雅可比矩阵。 $\\left[J\\left(\\mathcal{X}_{n+1}^{(k)}\\right)\\right]_{i, j}$ 表示雅可比矩阵的第 $i$ 行第 $j$ 列元素, 它可以通过差分法得到\n$$\n\\left[J\\left(\\mathcal{X}_{n+1}^{(k)}\\right)\\right]_{i, j} \\approx \\frac{h_{n+1, i}\\left(\\mathcal{X}_{n+1}^{(k)}+\\epsilon \\mathbf{e}_j\\right)-h_{n+1, i}\\left(\\mathcal{X}_{n+1}^{(k)}\\right)}{\\epsilon} .\n$$\n其中, $\\mathbf{e}_j$ 是第 $\\mathrm{j}$ 个元素为 1 的单位向量, $\\epsilon$ 是一个极微小量, $h_{n+1, i}$ 表示 $h_{n+1}$ 的第 $\\mathrm{i}$ 个自由度。\n\n### 残差的求解\n\n结合我们的数值格式, 对于任意给定的 $\\mathcal{X}_*$, 残差可以通过下面五个步骤 求解:\n$$\n\\begin{gathered}\n\\int_{B_r} \\mathbf{F}_* \\cdot \\mathbf{V} \\mathrm{d} \\mathbf{x}=\\int_{B_r} \\mathbb{P}_*: \\nabla \\mathbf{V} \\mathrm{d} \\mathbf{X}, \\\\\n\\mathbf{f}_*=\\int_{B_r} \\mathbf{F}_* \\delta\\left(\\mathbf{x}-\\mathcal{X}_n\\right) \\mathrm{d} \\mathbf{X}, \\\\\n\\left\\{\\rho\\left(\\frac{\\mathbf{u}_*-\\mathbf{u}_n}{\\Delta t}+\\mathbf{u}_n \\cdot \\nabla \\mathbf{u}^*\\right)-\\mu \\Delta \\mathbf{u}_{n+1}+\\nabla p_*=\\mathbf{f}_*,\\right. \\\\\n\\nabla \\cdot \\mathbf{u}^*=0, \\\\\n\\mathbf{U}_{n+1}\\left(\\mathcal{X}_*\\right)=\\int_{\\Omega} \\mathbf{u}_* \\delta\\left(\\mathbf{x}-\\mathcal{X}_{\\mathrm{n}}\\right) d \\mathbf{x},\n\\end{gathered}\n$$\n进而计算出残差 $\\mathbf{h}\\left(\\mathcal{X}_*\\right)$ 。\n\n### Jacobian-free Newton-Krylov 方法\n\n引入此算法的目的：原方法需要做 N + 1 次残差计算才能得到系数矩阵，Jacobian 矩阵的稀疏性未知，组装矩阵的组装与求解耗时。\nKrylov 子空间\n每步牛顿迭代都采用 Krylov 子空间法求解。令 $\\mathbf{b}=-h_{n+1}\\left(\\mathcal{X}_{n+1}^{(k)}\\right)$, $A=J\\left(\\mathcal{X}_{n+1}^{(k)}\\right), \\mathbf{x}=\\left(\\mathcal{X}_{n+1}^{(k+1)}-\\mathcal{X}_{n+1}^{(k)}\\right)$, 令初值 $\\mathbf{x}^{(0)}=\\mathbf{0}$, 那么残差为 $\\mathbf{v}=\\mathbf{b}$, 构造 $\\mathrm{n}$ 维 Krylov 子空间\n$$\n\\mathcal{K}_n(A, \\mathbf{v})=\\operatorname{span}\\left\\{\\mathbf{v}, A \\mathbf{v}, A^2 \\mathbf{v}, \\ldots, A^{n-1} \\mathbf{v}\\right\\} \\subseteq \\mathbb{R}^N\n$$\n其中 $n \\ll N$, 我们可以通过迭代法在空间 $\\mathcal{K}_n(A, \\mathbf{v})$ 中找到 $\\mathcal{X}_{n+1}$ 的近 似解\nJFNK 方法通过有限差分方法计算矩阵向量乘积, 无需知道 Jacobian 矩 阵\n$$\nA \\mathbf{v}=\\frac{\\mathbf{h}_{n+1}\\left(\\mathcal{X}_{n+1}^{(k)}+\\epsilon \\mathbf{v}\\right)-\\mathbf{h}_{n+1}\\left(\\mathcal{X}_{n+1}^{(k)}\\right)}{\\epsilon} .\n$$\n本文采用 BiCGStab 方法。为了保证整体的效率, $\\mathcal{X}_{n+1}^{(k+1)}$ 的求解通常不 要求达到很高的精度。\n\n\n\n\n\n\n\n1. 非线形求解器\n   1. Matrix-free Newton-Krylov 算法\n   2. 时间自适应算法\n2. CPU-GPU heterogeneous computing method\n\n## 结果","tags":["未完成","加密"]},{"title":"通过微信公众号在博客中发布动态","path":"/posts/14811/","content":"通过微信发布issue，从而更新博客中的个人动态。虽然这是一个小功能，但是后期仍需要大量改进，有时间会开一个github仓库存代码，目前就将所有代码放在这个文档里了。\n\n<!-- more -->\n\n## 前言\n\n流程如下：\n1. 在微信客户端给公众号发消息\n2. 微信服务器接受到消息，将数据转发给公众号后台服务器\n3. 公众号后台服务器下载数据，将数据处理后转发给GitHub服务器\n4. GitHub服务器将数据添加到仓库的issue中，至此，博客中能显示动态\n5. 公众号后台服务器接收到GitHub成功添加issue的通知\n6. 公众号后台服务器将通知转发给微信服务器\n7. 微信服务器将通知发送到微信客户端\n\n首先有个问题是微信服务器不会长期保存用户发送的数据，所以公众号服务器在处理数据时，需要将图片等数据从微信服务器上下载下来，上传到第三方服务器长期保存。这里可以选用GitHub仓库或者七牛云存储。\n\n还有一个问题，由于微信对个人订阅号的限制，我的公众号只能被动回复消息。即用户发一条消息，我回复一条。微信还限制了公众号必须在五秒内做出回应，否则判定服务器故障。因此，当用户发来视频等比较大的数据时，我不能在5秒钟内处理完，必须先给用户答复我已经收到消息了，之后再在后台处理。由于我不能主动向用户发送消息，因此在用户下次给我发消息前，我无法告知用户我是否已经成功处理完数据。这个问题很蛋疼。\n\n我在网上找到了类似功能的代码，一个是BBtalk，他的功能和我的类似，通过微信公众号发送个人的想法，小灵感等，经过公众号后台服务器转发，最终呈现在自己的博客中。只不过他用了leancloud的服务。\nhttps://bb.js.org/quick-start.html\n\n在此过程中，我还发现一个项目，mastodon(长毛象)，是一个去中心话社区，类似于微博、twitter等网站，而且提供了丰富的API，以后有时间再慢慢聊这个吧。\nhttps://www.zhihu.com/question/67166897/answer/2323395370\nhttps://mastodon.li\n## 通过 GitHub API 上传文件\n\n官方文档：\n\nhttps://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#about-the-repository-contents-api\n\n一篇相关博客(代码有错)：\n\nhttps://www.cnblogs.com/lizaza/p/12896536.html\n\n下面是我修改的代码：\n\n```python QIHS.py\nimport requests\nimport base64\nimport json\nimport hashlib\n\n# 参数设置\n# 我把GitHub图床翻译成 GitHub Image Hosting Service, 然后取他的简写为GIHS。\nGIHS_OWNER   = \"shaoyaoqian\"\nGIHS_REPO    = \"images-1\"\nGIHS_PATH    = \"test\"\nGITHUB_TOKEN = \"自己申请一个TOKEN\"\nurl_stensil  = \"https://api.github.com/repos/{owner}/{repo}/contents/{path}/{filename}\"\ncdn_stensil  = \"https://cdn.jsdelivr.net/gh/{owner}/{repo}/{path}/{filename}\"\n\n# 读取文件\ndef open_file(file_path):\n    with open(file_path, 'rb') as f:\n        return f.read()\n\n# 将文件转换为base64编码，上传文件必须将文件以base64格式上传\ndef file_base64(data):\n    sha = CalcSha1(data)\n    print(sha)\n    data_b64 = base64.b64encode(data).decode('utf-8')\n    return data_b64, sha\n\ndef CalcSha1(data):\n    # 哈希值的计算：https://stackoverflow.com/questions/7225313/how-does-git-compute-file-hashes/7225329#7225329\n    # 需要在原数据前加上 \"blob {字节长度}\\0\"\n    sha1obj = hashlib.sha1()\n    head = 'blob {}\\0'.format(len(data))\n    sha1obj.update(head.encode('utf-8'))\n    sha1obj.update(data)\n    hash = sha1obj.hexdigest()\n    return hash\n\ndef upload_file(filename):\n    file_data = open_file(filename)\n    token = GITHUB_TOKEN\n    url = url_stensil.format(owner=GIHS_OWNER, repo=GIHS_REPO, path=GIHS_PATH, filename=filename)\n    headers = {\"Authorization\": \"token \" + token}\n    content, sha = file_base64(file_data)\n    data = {\n        \"message\": \"Add a new file.\",\n        \"committer\": {\n            \"name\": \"robot\",\n            \"email\": \"github@robot.com\"\n        },\n        \"sha\":sha,\n        \"content\": content\n    }\n    data = json.dumps(data)\n    req = requests.put(url=url, data=data, headers=headers)\n    req.encoding = \"utf-8\"\n    re_data = json.loads(req.text)\n    # 能返回文件sha值表示上传成功\n    print(re_data)\n    print(re_data['content']['sha']) \n    # 在国内默认的down_url可能会无法访问，因此使用CDN访问\n    return cdn_stensil.format(owner=GIHS_OWNER, repo=GIHS_REPO, path=GIHS_PATH, filename=filename)\n\nif __name__ == '__main__':\n    filename = \"a.jpeg\"\n    upload_file(filename)\n```\n\n## 通过七牛云SDK上传文件\n\n```python QIHS\nfrom qiniu import Auth, put_file, etag\nimport qiniu.config\n\n# 七牛\nQINIU_ACCESS_KEY = \"NLI1UowRkIZiebmdEZ7MWNDLtPYeqJWkc90MFn_0\"\nQINIU_SECRET_KEY = \"NMgdo5YrD8zQhzc8ZGWH4t-pcGEeLOYzFYJZhiG-\"\nQINIU_CDN_BASE   = \"https://china-qiniu-s3.pengfeima.cn/\"\nQINIU_BUCKET     = 'pengfei-npu'\n\n# 上传到七牛云图床，参考：https://developer.qiniu.com/kodo/1242/python\n# 默认存储到\"blog/moments/\"路径下\ndef upload_file(filename, path=\"blog/moments/\"):\n    #构建鉴权对象\n    q = Auth(QINIU_ACCESS_KEY, QINIU_SECRET_KEY)\n    #要上传的空间\n    bucket_name = QINIU_BUCKET\n    #要上传文件的本地路径\n    localfile = filename\n    #上传后保存的文件名\n    key = path + filename\n    #生成上传 Token，可以指定过期时间等\n    token = q.upload_token(bucket_name, key, 3600)\n    ret, info = put_file(token, key, localfile, version='v2') \n    print(info)\n    assert ret['key'] == key\n    assert ret['hash'] == etag(localfile)\n    return QINIU_CDN_BASE + key\n```\n\n## 微信公众号后台程序\n\n```python wechat.py\n# 使用前提：云主机(其实用免费的vercel也可以)、域名、微信公众号、七牛云账号、GitHub账号\n# 参考 : \n# python 微信公众号开发[1] 后台服务器端配置与公众号开发配置\n# https://blog.csdn.net/jinxiaonian11/article/details/104708996/\n\n# pip3 install flask, xmltodict, octokitpy, qiniu\nfrom flask import Flask, request, abort, render_template\nimport hashlib\nimport xmltodict\nimport time, datetime\nimport json\nimport requests\nfrom octokit import Octokit\n\n# 下面两行代码分别是七牛云图床和GitHub图床的上传文件的方式\n# 使用一行即可\n# from GIHS import upload_file\nfrom QIHS import upload_file\n\n# 微信的token令牌，参数的获取可参考：https://qiniu.pengfeima.cn/typora/202212031457547.png\nWECHAT_TOKEN = 'look_back_at_me'\nWECHAT_APPID = \"wxcc6a1b8adade3237\",         \nWECHAT_SECRET = \"29b97cdfd439873420ecf78e8221fdea\"\n\n# GitHub\nGITHUB_TOKEN = \"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\"\nGITHUB_OWNER = 'shaoyaoqian'\nGITHUB_REPO  = \"MerryJingle\"\n\napp = Flask(__name__)\n\n# 获取微信的access token，在获取音频和视频文件时用得到\n# 注意：虽然官方文档有向用户发送视频文件的方法，但本人多次尝试无法成功。有人询问过微信官方，但是微信官方不置可否。\ndef get_access_token():\n    baseurl = \"https://api.weixin.qq.com/cgi-bin/token?\"\n    params = {\n        \"grant_type\":\"client_credential\",\n        \"appid\": WECHAT_APPID,         \n        \"secret\": WECHAT_SECRET\n    }\n    r = requests.get(baseurl, params=params)\n    access_token = r.json()[\"access_token\"]\n    try:\n        r = requests.get(baseurl, params=params)\n    except Exception as e:\n        print(e)\n    return access_token\n\ndef create_github_issue(title,body):\n    octokit = Octokit(auth='token', token=GITHUB_TOKEN)\n    issue = octokit.issues.create(owner=GITHUB_OWNER,repo=GITHUB_REPO,title=title,body=body)\n    message = \"成功发布动态！\\n日期：{}\\n内容：{}\\n\".format(issue.response.title,issue.response.body)\n    print(message)\n    return message\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef wechat():\n    \"\"\"验证服务器地址的有效性\"\"\"\n    # 开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数:\n    # signature:微信加密, signature结合了开发者填写的token参数和请求中的timestamp参数 nonce参数\n    # timestamp:时间戳(chuo这是拼音)\n    # nonce:    随机数\n    # echostr:  随机字符串\n    # 接收微信服务器发送参数\n    signature = request.args.get(\"signature\")\n    timestamp = request.args.get(\"timestamp\")\n    nonce = request.args.get(\"nonce\")\n\n    # 校验参数\n    # 校验流程：\n    # 将token、timestamp、nonce三个参数进行字典序排序\n    # 将三个参数字符串拼接成一个字符串进行sha1加密\n    # 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\n    if not all([signature, timestamp, nonce]):\n        # 抛出400错误\n        abort(400)\n\n    # 按照微信的流程计算签名\n    li = [WECHAT_TOKEN, timestamp, nonce]\n    # 排序\n    li.sort()\n    # 拼接字符串\n    tmp_str = \"\".join(li)\n    tmp_str = tmp_str.encode('utf-8')\n    # 进行sha1加密, 得到正确的签名值\n    sign = hashlib.sha1(tmp_str).hexdigest()\n    # 将自己计算的签名值, 与请求的签名参数进行对比, 如果相同, 则证明请求来自微信\n    if signature != sign:\n        # 代表请求不是来自微信\n        # 弹出报错信息, 身份有问题\n        abort(403)\n    else:\n        # 表示是微信发送的请求,第一次接入微信服务器的验证时才会使用\n        if request.method == \"GET\":\n            echostr = request.args.get(\"echostr\")\n            # 校验echostr\n            if not echostr:\n                abort(400)\n            return echostr\n\n        elif request.method == \"POST\":\n            # 表示微信服务器转发消息过来\n            # 拿取xml的请求数据\n            xml_str = request.data\n\n            # 当xml_str为空时\n            if not xml_str:\n                abort(400)\n\n            # 将xml字符串解析成字典\n            xml_dict = xmltodict.parse(xml_str)\n            xml_dict = xml_dict.get(\"xml\")\n\n            # MsgType是消息类型 这里提取消息类型\n            msg_type = xml_dict.get(\"MsgType\")\n\n            if msg_type == \"text\":\n                # 表示收到文本消息\n                # 构造xml格式的返回值,\n                # 返回值会经由微信服务器回复给用户\n                # 其中：\n                # ToUsername: (必须传) 接收方账号(收到的OpenID)\n                # FromUserName: (必须传) 开发者微信号\n                # CreateTime: (必须传) 消息创建时间(整形)\n                # MsgType: (必须传) 消息类型\n                # Content: (必须传) 回复消息的内容(换行:在Content中能够换行, 微信客户端就支持换行显示)\n\n                # 发布GitHub issue\n                title = time.strftime('%Y年%m月%d日 %H:%M:%S',time.localtime(time.time()))\n                body = xml_dict.get(\"Content\")\n                message = create_github_issue(title,body)\n\n                # 返回消息告知用户issue是否成功发布\n                resp_dict = {\n                    \"xml\":{\n                        \"ToUserName\":xml_dict.get(\"FromUserName\"),\n                        \"FromUserName\":xml_dict.get(\"ToUserName\"),\n                        \"CreateTime\":int(time.time()),\n                        \"MsgType\":\"text\",\n                        \"Content\":message\n                    }\n                }\n\n\n\n            elif msg_type == \"image\":\n                # PicUrl  图片链接\n                # MediaId 图片消息的媒体id，图片被归为临时素材，通过统一接口调用。\n                # \n                # resp_dict = {\n                #     \"xml\":{\n                #         \"ToUserName\":xml_dict.get(\"FromUserName\"),\n                #         \"FromUserName\":xml_dict.get(\"ToUserName\"),\n                #         \"CreateTime\":int(time.time()),\n                #         \"MsgType\":\"image\",\n                #         \"Image\":{\n                #             \"MediaId\":xml_dict.get(\"MediaId\")\n                #         }\n                #     }\n                # }\n                #\n                # 下载图片，以时间命名，为了确保图片文件名的唯一性，时间精确到纳秒(10^-6秒)，例如：2022-12-03-165018047661.png\n                filename = datetime.datetime.now().strftime(\"%Y-%m-%d-%H%M%S%f\")+\".png\"\n                r = requests.get(xml_dict.get(\"PicUrl\"))\n                with open(filename, 'wb') as f:\n                    f.write(r.content)\n                # 上传\n                picurl = upload_file(filename)\n                # 将图片链接改成markdown中的表达形式\n                body = \"![{}]({})\".format(filename, picurl)\n                # 发布issue\n                title = time.strftime('%Y年%m月%d日 %H:%M:%S',time.localtime(time.time()))\n                message = create_github_issue(title,body)\n                # 告知用户issue是否成功发布\n                resp_dict = {\n                    \"xml\":{\n                        \"ToUserName\":xml_dict.get(\"FromUserName\"),\n                        \"FromUserName\":xml_dict.get(\"ToUserName\"),\n                        \"CreateTime\":int(time.time()),\n                        \"MsgType\":\"text\",\n                        \"Content\":message\n                    }\n                }\n\n            else:\n                resp_dict = {\n                    \"xml\": {\n                        \"ToUserName\": xml_dict.get(\"FromUserName\"),\n                        \"FromUserName\": xml_dict.get(\"ToUserName\"),\n                        \"CreateTime\": int(time.time()),\n                        \"MsgType\": \"text\",\n                        \"Content\": \"我不想回复\"\n                    }\n                }\n            # 将字典转换为xml字符串\n            resp_xml_str = xmltodict.unparse(resp_dict)\n            print(resp_xml_str)\n            # 返回消息数据给微信服务器\n            return resp_xml_str\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n\n# sudo python3 wechat.py\n```","tags":["未完成"]},{"title":"为开源项目提交commit的简易教程","path":"/posts/26834/","content":"将自己的代码提交到他人的仓库中\n\n<!-- more -->\n\n\n\n## 前言\n\n今天我给Stellar主题增加了一个功能，想把代码提交到上游仓库的主分支上，因此开了一个 pull request 。这是我第一次使用 pull request ，我总结了以下一些经验。\n\n我自己在本地修改代码调试程序时，commit命令用得比较频繁，很多commit都是一些小修改，而且我会在代码中加入一些私货，我不想它们出现在别人的代码仓库中。我希望在pull request的时候只挑选出一些有用的commit，将它们合并成一个commit，再将它推送到上游仓库。\n\n\n\n不啰嗦了，直接写步骤吧～\n\n\n\n1. fetch 拉取上游仓库的主分支，将仓库的 upatream/main 分支更新到最新状态\n2. 在 upstream/main 分支创建并签出一个 dev 分支\n3. 使用 cherry-pick 挑选出有用的 commit 加到 dev 分支上\n4. 使用 rebase 将这些分支合并，并详写 message 解释代码的改动\n5. 在 github 上开启一个 pull requst 等待作者审阅代码","tags":["git"],"categories":["技术基础"]},{"title":"CFD问题中的稳定性分析","path":"/posts/55132/","content":"我只分析时间离散的稳定性前言&ensp;&ensp;&ensp;&ensp;长期以来，在网上一直能看到这样的论断：因为有限元方法不能使用迎风格式，所以求解CFD问题时会遇到稳定性问题。对此我很困惑，我困惑的是他们为什么要纠结显格式的稳定性问题，用隐格式或半隐格式就是无条件稳定的呀。例如下面这个数值格式$$\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}+\\boldsymbol{u}^{n+1}\\cdot\\nabla\\boldsymbol{u}^{n}=\\boldsymbol{f},$$用现代数值计算理论分析一下很容易得出它是无条件稳定的，并且我自己也用数值试验验证过。我认为标准的有限元方法可以求解CFD问题，重点在于构造稳定的时间离散格式和寻找满足LBB条件的有限元空间。我特别希望有人告诉我，我的想法是错的，我哪里错了或者我哪里没考虑到。&ensp;&ensp;&ensp;&ensp;我在李晓丽的论文中找到下面这样的论述：求解NS方程的诸多困难之一是如何处理非线性对流项。本质上有三种处理方式：1. 完全隐式，每个时间步都要求解一个非线性系统。2. 半隐式，每个时间步都要求解一个变系数椭圆方程，这意味着每个时间步都需要重新组装系数矩阵。3. 显式，每个时间步只需求解一次Stokes方程(两次Poisson型的方程，如果采用算子分裂格式)，但是有CFL条件限制，如果雷诺数较大，那么时间步长要取得非常小。&ensp;&ensp;&ensp;&ensp;在Daniel Boffi的论文里是这样考虑对流项的：NS方程中对流项的变分形式可以写成$$b(\\mathbf{u}, \\mathbf{v}, \\mathbf{w})=\\frac{\\rho_f}{2}((\\mathbf{u} \\cdot \\boldsymbol{\\nabla} \\mathbf{v}, \\mathbf{w})-(\\mathbf{u} \\cdot \\boldsymbol{\\nabla} \\mathbf{w}, \\mathbf{v})),$$这一项可以通过代入前一时间步的变量线性化，线性化后可以写成$$b\\left(\\mathbf{u}^n, \\mathbf{u}^{n+1}, v\\right).$$速度的无散度条件和适当的边界条件可以使这一项为零，不会影响数值格式的稳定性。时间离散空间连续晚上我在看一篇论文：里面涉及到不可压NS方程全离散格式的稳定性证明，他的证明特别简洁。文中假设了无散度速度场与梯度场是正交的，即$$(\\mathbf{u},\\nabla p)=0.$$这其实是对边界条件的要求，其他论文里一般会假设$\\mathbf{u}\\in H_0^1{(\\Omega)}$之类的条件。文中还直接使用了Laplace算子的负定性，即$$(\\Delta \\mathbf{u},\\mathbf{u})\\le0$$这样就能证明时间离散空间连续的情况是无条件稳定的。全离散下面是可以用投影法求解的全离散格式$$\\begin{aligned}&\\frac{\\mathbf{u}^*-\\mathbf{u}^n}{\\Delta t}=\\frac{v}{2} \\Delta^h\\mathbf{u}^* +\\mathbf{f}\\\\&\\Delta^h \\phi=\\frac{1}{\\Delta t} \\nabla^h \\cdot \\mathbf{u}^* \\\\&\\mathbf{u}^{n+1}=\\mathbf{u}^*-\\Delta t \\nabla^h \\phi\\end{aligned}$$为了证明我们的数值格式是无条件稳定的，在空间离散后，第一个条件就是要求算子$\\Delta_h$和算子$\\nabla_h$满足可交换性，即$$\\Delta_h\\nabla_h\\phi=\\nabla_h\\Delta_h\\phi$$这就要求$$\\Delta_h=\\nabla_h\\cdot\\nabla_h$$其次，我们还要求边界条件满足适当要求，使得离散的无散度场和离散的梯度场是正交的，最后还用到了离散Laplace算子的负定性。对流项对流项使用半隐格式就可以了。投影方法中对流项对稳定性的影响$$\\begin{aligned}&\\int_{\\Omega}\\mathbf{u}\\cdot\\nabla\\mathbf{v}\\cdot\\mathbf{w}\\;\\mathrm{d}\\mathbf{x}\\\\=&\\int_{\\Omega}\\sum_{i,j}^d u_i\\partial_iv_jw_j\\;\\mathrm{d}\\mathbf{x}\\\\=&\\int_{\\Omega}\\sum_{i,j}^d \\partial_i (u_iv_jw_j)\\;\\mathrm{d}\\mathbf{x}-\\int_{\\Omega}\\sum_{i,j}^d \\partial_i (u_iw_j)v_j\\;\\mathrm{d}\\mathbf{x}\\\\=&\\int_{\\Omega}\\sum_{i,j}^d \\partial_i (u_iv_jw_j)\\;\\mathrm{d}\\mathbf{x}-\\int_{\\Omega}\\sum_{i,j}^d \\partial_i u_iw_jv_j\\;\\mathrm{d}\\mathbf{x}-\\int_{\\Omega}\\sum_{i,j}^d \\partial_i w_ju_iv_j\\;\\mathrm{d}\\mathbf{x}\\end{aligned}\\tag{1}$$在用能量放法分析投影方法时，中间会出现一项$$\\int_{\\Omega}\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_*\\cdot\\mathbf{u}_{n+1}\\;\\mathrm{d}\\mathbf{x}\\tag{2}$$其中，$\\nabla\\cdot\\mathbf{u}_n=0$，$\\nabla\\cdot\\mathbf{u}_{n+1}=0$，$\\mathbf{u}_{n+1}=\\mathbf{u}_{*}$。适当假设边界条件，$\\mathbf{u}_{\\partial\\Omega}=\\mathbf{0}$或者$\\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{n}}_{\\partial\\Omega}=\\mathbf{0}$。根据(1)的推导，可以得出$$\\int_{\\Omega}\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_*\\cdot\\mathbf{u}_{n+1}\\;\\mathrm{d}\\mathbf{x}+\\int_{\\Omega}\\mathbf{u}_n\\cdot\\nabla\\mathbf{u}_{n+1}\\cdot\\mathbf{u}_{*}\\;\\mathrm{d}\\mathbf{x}=0\\tag{3}$$进而得出$$\\int_{\\Omega}\\mathbf{u}_{n}\\cdot\\nabla (\\mathbf{u}_*\\cdot \\mathbf{u}_{n+1})\\;\\mathrm{d}\\mathbf{x}=0\\tag{4}$$其实得出这个也没用。必须是后两项相等的情况下才能得出:$$\\int_{\\Omega}\\mathbf{u}\\cdot\\nabla\\mathbf{v}\\cdot\\mathbf{v}\\;\\mathrm{d}\\mathbf{x}=0$$"},{"title":"多重网格方法求解不可压流体","path":"/posts/3240/","content":"> 翻译自 A parallel multigrid Poisson solver for fluids simulation on large grids\n\n## 1. 前言\n\n略\n\n### 我们主要的贡献\n\n在[[自由表面流]]模拟中，混合了任意Dirichlet边界和Neumann边界的非规则[[体素化区域]]很常见，我们给出了处理这种问题的通用方法。之前有文章提出矩形区域上的几何多重网格方法[TO94, AF96, BWRB05, BWKS06, KH08]，也有文章提出非规则Neumann边界条件的处理(通过投影方法)[MCPN08]，但是没有将问题推广到一般情况。\n\n我们使用了纯几何的、无矩阵的格式，并且收敛率能保持在常数的，与边界、几何无关。[BWRB05]提出了一种轻量的、无矩阵的几何多重网格方法应用于均匀的矩形区域的求解，然而将它推广到体素化区域很困难。[HMBVR05]在离散边界时嵌入了切割单元，导致体素化Poisson方程的离散不收敛，因为边界处出现了不稳定现象(啥不稳定?)。据[CLB09]所说， 即使使用高阶嵌入也不能得到常数收敛率，他们在嵌入[[背景格子]]的表面网格上求解Poisson方程时，注意到当[[格子]]不能解析网格时，收敛率会退化。由于找到收敛的几何解很困难[CFL07,CGR04,PM04]，很多人选择使用更加通用的代数多重网格方法，但是代数多重网格方法的初始化很耗费资源，并行化困难[TOS01]。\n\n相较于广泛使用的ICPCG(incomplete Cholesky preconditioned conjugate gradient)求解器，我们的方法占用的内存少，收敛效果更好，并且更容易并行化。不像ICPCG，我们的方法不用显式存储预处理矩阵，能够在16GB内存中处理$768^2\\times 1152$个体素。ICPCG需要稀疏回代过程(sparse backsubstition)，为了让这过程能够并行化，算法上需要做很多调整，而我们提出的方法不存在这个问题。最后，在中等规模的问题上，我们的求解器的速度相对于ICPCG有大幅提升，并且收敛率与网格大小无关，因此随着问题规模增加，我们的优势会更加明显。对于分辨率为$128^3$的问题，我们可以在0.75秒内使残差下降$10^4$，对于$768^3$的问题则只需大约一分钟。\n\n## 2. 相关工作\n\n多重网格方法的效率非常高，它在图形学中的应用非常多，包括图像处理[KH08, BWKS06, RC03], 烟雾模拟[MCPN08]，网格变形[SYBF06], 薄壳模拟 [GTS02], 布料模拟 [ONW08], 流体模拟 [CFL∗07, CTG10], 几何处理 [NGH04], 固体形变模拟 [OGRG07], 渲染 [Sta95, HMBVR05], 并已有效地移植到GPU [BFGS03, GWL∗03, GSMY∗08]。该领域大量工作聚焦于矩形区域的求解或者结合代数多重网格方法在非规则区域的求解，我们给出一些涉及了非规则区域和几何多重网格的工作。[HMBVR05]和[CLB∗09]将非规则区域嵌入规则的格子中，给出了非规则模板(用于迭代的模板？)。[RC03, ONW08]使用了从粗到细的几何网格层次，保证了不同网格层之间的网格能够对齐，但是这些方法要求网格在粗网格层能够完全解析(细网格由粗网格决定)， 因此这种方法无法解析精细的流体特征[SAB∗99]将多重网格作为CG方法的预处理器使用，而不是独立的求解器，这样能缓解一些算例中出现的不稳定现象。 多重网格方法作为预处理器求解Poisson方程可以参考论文 [Tat93] 它的并行化可参考 [TO94] 以及 [AF96]。[KH08] 引入了高阶并行多重网格求解器处理大型矩形图像。\n\n## 3. 方法概览\n\n我们要求解的是Poisson方程，见式(1)。\n$$\n\\begin{gathered}\n\\Delta p=f \\text { in } \\Omega \\subset \\mathbf{R}^3 \\\\\np(\\mathbf{x})=\\alpha(\\mathbf{x}) \\text { on } \\Gamma_D, \\quad p_n(\\mathbf{x})=\\beta(\\mathbf{x}) \\text { on } \\Gamma_N\n\\end{gathered} \\tag{1}\n$$\n\n区域边界 $\\partial \\Omega=\\Gamma_D \\cap \\Gamma_N$ 被分成两个不相交的子集 $\\Gamma_D$ 和 $\\Gamma_N$ ，分别施加\nDirichlet边界条件和Neumann边界条件。对于流体模拟， $\\Omega$ 对应物体或液体，Dirichlet边界条件施加在空气和水的界面上，Neumann边界条件施加在流体和浸没固体(或容器内壁)的边界。不失一般性，我们假设Neumann边界条件为零 $(\\beta(\\mathbf{x})=0)$ ，因为非零边界条件可以通过修改右端项实现。\n\n> 注：这其实很好理解，速度为Dirichlet边界的时候，压强为Neumann边界。\n\n![image-20221125084844500](https://githubimages.pengfeima.cn/images/202211250848864.png)\n\n![image-20221125085225087](https://githubimages.pengfeima.cn/images/202211250852187.png)\n\n### 3.1 离散\n\n我们将Poisson方程在均匀的笛卡尔网格上离散，将未知的压强变量 $p_{ijk}$ 存储在单元格的中心。在我们的方法中，计算区域和边界区域的精度由背景网格决定。具体来说，计算区域以一系列网格单元(或体素)来表示，我们称它们是内部单元(图一右中的灰色单元)。我们将边界单元也体素化，将Dirichlet边界条件定义在一个体素化区域，而不是将它施加在边界 $\\partial \\Omega$ 上。我们称之为Dirichlet单元(图一右中的红色单元)。类似地，我们可以通过栅格化固体和容器内壁定义Neumann单元(图一右中的蓝色单元)。\n\n因为压强定义在单元中心，Neumann边界条件可以很自然地施加在内部单元和Neumann单元的分界面上，我们在第四节中会给出简单实现。我们假设我们的计算区域周围一直都有Neumann单元作为“ghost”层，如图一所示。这样的假设不是一般性，因为对于Dirichlet边界，我们再加一层额外的Neumann单元也不影响$\\Omega$中的结果。对每一个内部单元，我们构造出如下Poisson方程的离散格式：\n$$\n\\begin{gathered}\n\\sum_{\\left(i^{\\prime}, j^{\\prime}, k^{\\prime}\\right) \\in \\mathcal{N}_{i j k}^*} \\frac{p_{i^{\\prime} j^{\\prime} k^{\\prime}}-p_{i j k}}{h^2}=f_{i j k} \\\\\n\\mathcal{N}_{i j k}=\\{(i \\pm 1, j, k),(i, j \\pm 1, k),(i, j, k \\pm 1)\\} \\\\\n\\mathcal{N}_{i j k}^*=\\left\\{\\left(i^{\\prime}, j^{\\prime}, k^{\\prime}\\right) \\in \\mathcal{N}_{i j k}: \\operatorname{cell}\\left(i^{\\prime}, j^{\\prime}, k^{\\prime}\\right) \\text { is not Neumann }\\right\\}\n\\end{gathered}\n\\tag{2}\n$$\n\n在这个定义中， $\\mathcal{N}_{i j k}$ 表示和内部单元 $(i,j,k)$ 有共同表面的六个邻接单元的集合， $\\mathcal{N}_{i j k}^*$ 是 $\\mathcal{N}_{i j k}$ 的子集，排除了任意Neumann单元。 $h$ 表示网格步长。方程 (2) 是从标准的七点有限差分方法修改得到的，用零Neumann边界条件 $\\left(p_{i^{\\prime} j^{\\prime} k^{\\prime}}-p_{i j k}\\right) / h=0$保证Neumann边界上的压强为零。在内部单元上，是标准的七点有限差分方法。这个公式和[FM96,FF01]中的公式是一样的。\n\n### 3.2 多重网格迭代\n\n我们介绍用几何多重网格方法求解式(2)定义的Poisson问题。我们的方法使用了V-Cycle作为多重网格校正格式[TOS01]，Algorithm 1给出了每一次V-Cycle迭代的伪代码。\n\nV-Cycle 过程需要将Poisson在$L+1$层网格上离散，将这些网格记为 $\\mathcal{L}^{(0)}, \\mathcal{L}^{(1)}, \\ldots, \\mathcal{L}^{(L)}$，其中 0 层网格是最细的网格，L层网格是最粗的网格。我们也定义了每一层网格的光滑子和不同网格层之间的限制/插值算子。\n\n\n![image-20221125150439242](https://githubimages.pengfeima.cn/images/202211251504398.png)\n\n我们的方法是纯几何的，我们构造出每一层网格的像素化描述，将单元分类为内部单元、Dirichlet单元、Neumann单元。根据像素化表示构造出离散的Poisson算子$\\mathcal{L}$。每一层网格的粗化采用8-1的模板，生成网格间距为原网格两倍的粗网格。我们的层次结构很深：最粗的网格层通常是$8 \\times 8\\times 8$。这样的粗化方法能够保证粗网格边界始终与细网格一致(见图2)。\n\n如果一个粗网格单元粗化前的八个细网格单元中的任何一个是Dirichlet单元，那么它将被标记为Dirichlet单元。如果八个细网格单元中没有一个是Dirichlet单元，但至少有一个是内部单元，那么粗网格单元将被标记为内部单元。其他情况，则将粗网格单元标记为Neumann单元。\n\n如图2所示，当粗网格不能精确解析细网格的特征时，这种粗化策略会导致细网格和粗网格之间存在显著差异，甚至会改变区域的拓扑结构，例如Neumann气泡会被吸收进内部区域，薄层状的内部区域会被吸收进Dirichlet区域。我们待会儿介绍这些差异会造成的影响。\n\n\n\n限制算子通过张量积木板构造， $\\mathcal{R}=\\mathcal{B} \\otimes \\mathcal{B} \\otimes \\mathcal{B}$ ，其中 $\\mathcal{B}$ 是 $1 \\mathrm{D}$ 模板，由4节点构成：\n$$\n\\begin{aligned}\n\\left(\\mathcal{B} \\mathbf{u}^h\\right)(x)=& \\frac{1}{8} u^h\\left(x-\\frac{3 h}{2}\\right)+\\frac{3}{8} u^h\\left(x-\\frac{h}{2}\\right)+\\\\\n&+\\frac{3}{8} u^h\\left(x+\\frac{h}{2}\\right)+\\frac{1}{8} u^h\\left(x+\\frac{3 h}{2}\\right)=u^{2 h}(x)\n\\end{aligned}\n$$\n图三左给出了该张量积木板的2D形式，由16个节点构成。因为我们的变量位于单元格中心，因此粗网格上的变量和细网格上的变量不会有位置重合的。\n\n延拓算子通过 $\\mathcal{P}^I=8 \\mathcal{B} \\otimes \\mathcal{B} \\otimes \\mathcal{B}$ 定义，换句话说，就是转置、缩放后的限制算子我们可以验证这个延拓算子是一个三线性插值算子。只有当限制算子或插值算子的输出结果位于内部单元上时，我们才使用它们。当限制算子或插值算子的输入不位于内部单元时，我们用零值代替。\n\n\n\n我们使用系数为$w=2/3$的加权Jacobi迭代，用它求解Poisson方程是稳定的，并且在并行效率上比Gauss-Seidel方法好。对于具有混合边界条件和不规则几何区域的问题，通常要在计算区域边界附近执行额外的迭代计算。我们将距离Dirichlet单元或Neumann单元三个单元以内的内部单元记为边界区域，如图三右的黑色阴影区域所示。总之，我们在边界区域进行一些额外的Gauss-Seidel迭代，在整个区域进行加权Jacobi迭代。具体来说，我们一开始会在边界区域进行数次Gauss-Seidel迭代，然后再在整个区域进行加权Jacobi迭代，最后再在边界进行额外的Gauss-Seidel迭代。\n\n### 3.3 多重网格预处理共轭梯度\n\n## 4. 实现与优化\n\n## 5. 算例","tags":["未完成"]},{"title":"GitHub图床搭配又拍云CDN加速","path":"/posts/27346/","content":"## 具体步骤\n\n> 原理：将仓库发布为静态网页，可以绑定自定义域名，通过自定义域名加速。发布静态网页后可以通过 xxx.github.io/images/xxx.png 访问这个仓库中的图片，现在通过自定义域名 images_0.example.com/images/xxx.png 访问，将 images_0.example.com 做一下CDN加速，这样就能在国内快速访问这些资源了。如果一个仓库满了可以再建一个仓库，例如images_1，images_2等等，绑定新的域名即可。以后如果不想用github图床，可以迁移，只要将域名和仓库相对应即可\n\n在个人设置中添加自定义域名\n\n![image-20221123154404250](https://githubimages.pengfeima.cn/images/202211231544344.png)\n\n新建仓库后，在仓库设置中开启Pages功能，并设置自定义域名\n\n![](https://githubimages.pengfeima.cn/images/202211231304598.png)\n\n在PicGo中设置自定义域名\n\n![](https://githubimages.pengfeima.cn/images/202211231311540.png)\n\n最后在又拍云中加速这个自定义域名\n\n## 这算不算滥用？\n\n这个网站主要使用了GitHub提供的服务，因此我研究了一下他们的服务条款。\n\nhttps://docs.github.com/cn/site-policy/github-terms/github-terms-for-additional-products-and-features\n\n这里说了，不要将GitHub Action拿来提供CDN服务和无服务器云计算服务，这会给GitHub服务器带来很大负担。但GitHub没有禁止这种行为，因为后面又说了，如果这些行为不会给他们服务器带来很大负担，那你用一用也没事。我们用GitHub Action编译Hexo网站当然不算CDN服务和无服务器云计算服务。\n\n![image-20221121162522531](https://githubimages.pengfeima.cn/images/202211211625795.png)\n\nhttps://docs.github.com/cn/pages/getting-started-with-github-pages/about-github-pages\n\nGitHub Pages也有使用限制，仓库不能超过1GB，发布的网站不能超过1GB，每个月带宽不能超过100GB，这已经远大于我的使用需求了。\n\n![image-20221121163128276](https://githubimages.pengfeima.cn/images/202211211631406.png)\n\nhttps://docs.github.com/cn/repositories/working-with-files/managing-large-files/about-large-files-on-github\n\nGitHub 仓库的体积没有明确说有体积限制，建议在1GB以下，超过5GB会发邮件提醒你，但没有强制性的要求。但是如果这个仓库按照上面说的，使用了自定义域名作为图床链接，那么仓库会被限制在1G以内，否则就加速失效了。\n\n![image-20221121164723161](https://githubimages.pengfeima.cn/images/202211211647289.png)\n\n综上，只要不给他们的服务器带来很大的负担，把GitHub仓库当个人图床使用根本不会有人来管你。\n\n## CDN服务的选择\n\n### 七牛云\nHttps收费，http有10G免费流量。\n\n### Cloudfare\nCloudflare提供的CDN服务是免费的，SSL也是免费的，但是Cloudflare的服务器全在国外，大陆访问特别慢。\n\n![image-20221121182202707](https://githubimages.pengfeima.cn/images/202211211822833.png)\n\n### 又拍云\n和七牛云差不多，但是如果在自己网站上挂个[广告](https://www.upyun.com/league)，那么可以免费使用一年\n\n我使用了又拍云CDN加速。","categories":["网站建设"]},{"title":"在Stellar主题中使用数学公式","path":"/posts/5207/","content":"前言在使用时默认插件时，很多公式都显示不出来，默认配置文档里说推荐使用Pandoc，我就尝试了一下。启用Mathjax插件去主题配置文件`themes/stellar/_config.yml`中找一找`mathjax`的配置，拷贝到我们自己的配置文件中。```yaml _config.stellar.ymlplugins: # MathJax # 需在Markdown文件开头加入mathjax: true # 推荐使用Pandoc: npm uninstall hexo-renderer-marked --save & npm install hexo-renderer-pandoc --save mathjax: enable: true cdn: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML```将插件修改成启用`enable: true`，重新编译一下就能生效了。```bashhexo clean && hexo generate && hexo serve```但是有很多公式显示不出来，我们要将默认的插件hexo-renderer-marked换成hexo-renderer-pandoc。在命令行里输入以下命令修改插件。```bashnpm uninstall hexo-renderer-marked --save npm install hexo-renderer-pandoc --save```因为hexo-renderer-pandoc依赖于Pandoc，我们还要在电脑上安装pandoc，我用的是MacOS，可以通过homebrew安装，安装好后，重新生成一下就好了。```bashbrew install pandochexo clean && hexo generate && hexo serve```现在我们能看到全部公式了，以下分别是hexo-renderer-marked和hexo-renderer-pandoc的显示效果。 hexo-renderer-marked hexo-renderer-pandoc最后，因为hexo-renderer-pandoc依赖Pandoc，如果要通过GitHub Action发布，那么需要在yml文件中添加：```yaml # 在step下面加上 - name: Install Pandoc run:  wget https://github.com/jgm/pandoc/releases/download/2.7.2/pandoc-2.7.2-1-amd64.deb sudo dpkg -i pandoc-2.7.2-1-amd64.deb # Other steps # ......```存在问题时间线出现了问题。如果不想用pandoc了，那么就删除pandoc，切换回hexo-renderer-marked，一切都可以恢复原样。反正我是放弃了，博客里写那么多公式干嘛。```bashbrew uninstall pandocnpm install hexo-renderer-marked --save npm uninstall hexo-renderer-pandoc --save```问题的解决不要用hexo-renderer-marked和hexo-renderer-pandoc，用hexo-renderer-kramed，输入三行命令解决所有问题。```npm uninstall hexo-renderer-marked --save npm uninstall hexo-renderer-pandoc --savenpm install hexo-renderer-kramed --save```Hexo 搭建个人博客（完结）Hexo 相关问题和优化pandoc完美解决MathJax中多行公式和Markdown的冲突{% note color:warning 问题2：行内公式有`_`时，需要替换成`\\_`，否则会被识别为markdown语言`_斜体_`用 katex + hexo-renderer-markdown-it-plus 替换了 mathjax + hexo-renderer-kramed。参考: https://www.micdz.cn/article/katex-on-volantis/更新: 2022-11-26%}","categories":["网站建设"]},{"title":"利用Github Action部署博客","path":"/posts/52166/","content":"## 前言\n\n在看了大佬[Felix Chen](https://blog.felixchen0707.cn/)的博客[利用Github Action部署博客](https://blog.felixchen0707.cn/posts/477696ac/)后，我也在GitHub上部署了自己的博客，创建了两个仓库，一个当源码仓库，一个当网页仓库。我就讲讲跟他不一样的地方吧。\n\n\n## 使用submodule命令\n\n\n与他不同的是，我使用了submodule来保持stellar主题的最新状态。源代码仓库每次更新后，都会自动拉取最新版本的stellar主题，然后编译、发布。\n\n> fork一份到自己仓库，不仅能实时更新，还能自定义修改。\n\n```bash\ngit submodule add https://github.com/shaoyaoqian/hexo-theme-stellar.git themes/stellar\n```\n\n![image-20221117092135605](https://githubimages.pengfeima.cn/images/202211170921653.png)\n\n![image-20221117092004634](https://githubimages.pengfeima.cn/images/202211170920796.png)\n\n![image-20221117092357612](https://githubimages.pengfeima.cn/images/202211170923699.png)\n\n## 网页仓库的发布任务\n我的网页仓库不以.github.io结尾，网页仓库更新后，网站内容不会自动更新。因此需要添加一个脚本文件执行发布任务。详细来说，源码仓库的更新会触发源码仓库执行编译命令，源码仓库完成编译后，将生成的文件发布到网页仓库，网页仓库收到文件会触发自己的发布任务，发布新的网站。\n\n![image-20221117092524566](https://githubimages.pengfeima.cn/images/202211170925661.png)\n\n通过GitHub Action创建GitHub Pages时，会生成一个默认的static.yml，我就是复制了这个文件，放在网页仓库中。\n\n```yaml .github/workflows/autodeploy.yml\n# Simple workflow for deploying static content to GitHub Pages\nname: Deploy static content to Pages\n\non:\n  # Runs on pushes targeting the default branch\n  push:\n    branches: [\"main\"]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\n# Allow one concurrent deployment\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\n\njobs:\n  # Single deploy job since we're just deploying\n  deploy:\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Pages\n        uses: actions/configure-pages@v2\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v1\n        with:\n          # Upload entire repository\n          path: '.'\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v1\n```\n\n之后，我们只要在源码仓库提交文件就行了，后面GitHub Action会自动发布网站。","categories":["网站建设"]},{"title":"ubuntu系统配置clash代理","path":"/posts/62627/","content":"# [ubuntu配置clash系统代理](https://zhuanlan.zhihu.com/p/430035973)\n\n> 本文仅简要记录过程\n\n```bash\ncd ~\nwget http://qiniu.pengfeima.cn/clash-linux-amd64-v1.11.12.gz\ngunzip clash-linux-amd64-v1.11.12.gz\nmv clash-linux-amd64-v1.11.12 clash\nmkdir Clash\nmv clash ./Clash\n```\n\n```bash\ncd ~/Clash\nwget -O Country.mmdb http://qiniu.pengfeima.cn/Country.mmdb\n```\n\n1. 在windows版的clash中找到yaml文件\n2. 打开并加入`secret:123456`\n3. 将其拷贝到clash文件夹中\n4. 在网络设置中设置代理\n\n![image-20221109201937656](http://qiniu.pengfeima.cn/typora/image-20221109201937656.png)\n\n![image-20221109202226593](http://qiniu.pengfeima.cn/typora/image-20221109202226593.png)\n\n![image-20221109202210698](http://qiniu.pengfeima.cn/typora/image-20221109202210698.png)\n\n![image-20221109202339678](http://qiniu.pengfeima.cn/typora/image-20221109202339678.png)\n\n1. 启动clash\n2. 在浏览器中打开http://clash.razord.top/面板\n3. 输入参数\n\n```bash\ncd ~/Clash\nchmod +x clash\n./clash -d .\n```\n\n![image-20221109202650007](http://qiniu.pengfeima.cn/typora/image-20221109202650007.png)\n\n[ubuntu配置clash系统代理](https://zhuanlan.zhihu.com/p/430035973)\n\n```bash\ncd ~\nwget http://qiniu.pengfeima.cn/clash-linux-amd64-v1.11.12.gz\ngunzip clash-linux-amd64-v1.11.12.gz\nmv clash-linux-amd64-v1.11.12 clash\nmkdir Clash\nmv clash ./Clash\n```\n\n```bash\ncd ~/Clash\nwget -O Country.mmdb http://qiniu.pengfeima.cn/Country.mmdb\n```\n\n1. 在windows版的clash中找到yaml文件\n2. 打开并加入`secret:123456`\n3. 将其拷贝到clash文件夹中\n4. 在网络设置中设置代理\n\n![image-20221109201937656](http://qiniu.pengfeima.cn/typora/image-20221109201937656.png)\n\n![image-20221109202226593](http://qiniu.pengfeima.cn/typora/image-20221109202226593.png)\n\n![image-20221109202210698](http://qiniu.pengfeima.cn/typora/image-20221109202210698.png)\n\n![image-20221109202339678](http://qiniu.pengfeima.cn/typora/image-20221109202339678.png)\n\n1. 启动clash\n2. 在浏览器中打开http://clash.razord.top/面板\n3. 输入参数\n\n```bash\ncd ~/Clash\nchmod +x clash\n./clash -d .\n```\n\n![image-20221109202650007](http://qiniu.pengfeima.cn/typora/image-20221109202650007.png)\n\n至此，能正常访问谷歌学术。\n\n命令行代理：\n\n```bash\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n```","tags":["linux"]},{"title":"CDN加速","path":"/posts/17107/","content":"之前一直没弄明白CDN加速是怎么回事，自己捋了一下。\n\n我的博客搭建在[GitHub Pages](https://pages.github.com)上，通过域名xxx.github.io直接访问github的服务器，xxx.github.io叫做源站域名。使用了CDN加速服务后，CDN服务器会缓存源站的资源，之后我们浏览网页时就不用直接访问源站了，从CDN服务器上下载资源即可，这样就缓解了源站的压力。\n\n\n\n这中间域名需要经过两次转换，自定义域名 $\\rightarrow$ CDN加速域名 $\\rightarrow$ xxx.github.io。其中，自定义域名是自己购买的域名，CDN加速域名是CDN服务商提供的，xxx.github.io是GitHub提供的源站。我们要先在CDN服务商处设置自定义域名和源站域名，如下图所示：\n\n![image-20221106023304874](https://raw.githubusercontent.com/mapengfei-nwpu/personal_pictures/main/typora_picgo/202211060233060.png)<small>七牛云CDN服务的设置</small>\n\n设置好后，CDN服务商会提供一个CDN加速域名，复制这个CDN加速域名，到购买域名的地方，将自定义域名解析到CDN加速域名。最后再在GitHub Pages上设置自定义域名访问。这样就设置好了。接下来，我们访问网站时会发生一系列跳转：用户通过浏览器访问自定义域名(www.pengfeima.cn)$\\rightarrow$CDN加速域名(xxxxxx.xxxx.qiniu.com)$\\rightarrow$ 源站域名(shaoyaoqian.github.io)。\n\n\n\n我们可以自行设置CDN服务器的缓存策略。缓存是有时限的，过了时限后，CDN服务器上的资源会失效，CDN服务器会从源站调取资源重新缓存。放宽缓存时限会减少源站的压力，但是用户可能访问不到最新的内容。\n\n![image-20221107174824742](https://raw.githubusercontent.com/mapengfei-nwpu/personal_pictures/main/typora_picgo/202211071748920.png)\n\n<small>缓存时间设置</small>\n\n国内CDN加速有两个限制：\n\n- 开启HTTPS服务需要CA证书，否则只能使用HTTP服务。\n- 域名如果没有备案，那么只能覆盖海外CDN服务器。搭建在国内服务器上的网站需要备案，搭建在国外服务器上的网站无需备案，也无法备案。","categories":["网站建设"]},{"title":"用beamer做演示稿","path":"/posts/20229/","content":"## 首页和页脚\n\n![image-20221103145317607](https://raw.githubusercontent.com/mapengfei-nwpu/personal_pictures/main/typora_picgo/202211031453708.png)\n\n------\n\n## 块环境和定理环境\n\nbeamer中的环境有两类即block和theorem，都是\\begin和\\end的结构。不同的是定理环境还有一些额外的功能，例如进行编号之类。\n\n### 块环境(block)\n\n默认块环境的一共有三种，block、alertblock和exampleblock，以下是使用方式和显示效果。\n\n```latex\n% Frame 1\n\\begin{frame}{Basic Blocks}\n    \\begin{block}{Standard Block}\n        This is a standard block.\n    \\end{block}\n    \\begin{alertblock}{Alert Message}\n        This block presents alert message.\n    \\end{alertblock}\n    \\begin{exampleblock}{An example of typesetting tool}\n        Example: MS Word, \\LaTeX{}\n    \\end{exampleblock}\n\\end{frame}\n```\n\n![image-20221103135207499](https://githubimages.pengfeima.cn/images/202211282321932.png)\n\n对于块环境而言，可以通过**block**来设置块环境的通用属性，是否是圆角，是否带阴影。而块的颜色可以通过**块名+title/block**设置。例如对于alertblock，标题可以用\\setbeamercolor{block title alerted }{fg=,bg=}，block环境类似。\n\n### 定理环境(theorem)\n\n定理环境的template继承自block，色彩继承自structure，因此对于定理环境，并没有针对每一个定理环境的色彩和字体设置，不管是theorem还是example，属性是完全一样的，只是title的格式不一样。例如，对于theorem，标题是“定理1.2: 吃饭不饿定理”，对于example，标题是“例3.1： 吃饭不饿的反例”。所以定理环境没有太大修改的余地。\n\nbeamer中默认的定理环境包括theorem、definition、proof、example，我们可以自己增加新的定理环境，格式如下：\n\n新定义定理环境：`\\newtheorem{name}[counter]{text}[section]`\n\n- name：标识这个环境的关键字（用于编程）\n- text：真正在文档中打印出来的定理环境的名字\n- counter：计数器；一般新定义的定理环境会自己用一个新的计数器，但是可以在 counter 中传入其他的定理环境，表示和这个环境共用计数器。\n- section：定理编号依赖于某个章节层次（比如：定理1.1）\n\n以下是简单例子：\n\n1. 首先增加假设环境。\n\n   ```latex\n   \\newtheorem{hypothesis}{假设}                            \n   ```\n\n2. 然后在PPT里面使用它。\n\n   ```latex\n   \\begin{frame}\n       \\frametitle{应变能函数需要满足的条件}\n       \\begin{hypothesis}[应变能函数的假设]\n           令$\\mathbb{H}$为对 $W$ 二阶求导得到的四阶张量：\n           $$\n           \\mathbb{H}_{\\alpha i \\beta j}:=\\frac{\\partial^2 W}{\\partial \\mathbb{F}_{\\alpha i} \\partial \\mathbb{F}_{\\beta j}} \\text {. }\n           $$\n           假设存在$\\kappa_{\\min },\\kappa_{\\max }>0$使得\n           $$\n           \\kappa_{\\min } \\mathbb{E}^2 \\leqslant \\mathbb{E}: \\mathbb{H}: \\mathbb{E} \\leqslant \\kappa_{\\max } \\mathbb{E}^2\n           $$\n           对任意二阶张量$\\mathbb{E}$成立。其中， $\\mathbb{E}^2=\\mathbb{E}: \\mathbb{E}, \\quad \\mathbb{E}: \\mathbb{H}: \\mathbb{E}=\\mathbb{E}_{\\alpha i} \\mathbb{H}_{\\alpha i \\beta j} \\mathbb{E}_{\\beta j}$。\n       \\end{hypothesis}\n   \\end{frame}\n   ```\n   ![image-20221103134814663](https://githubimages.pengfeima.cn/images/202211282321206.png)\n\n参考：\n\nhttps://zhuanlan.zhihu.com/p/138021900\n\nhttps://zhuanlan.zhihu.com/p/133244838\n\n## 算法环境\n\n需要使用包`\\usepackage{algorithm,algorithmic}` ，示例如下：\n```latex\n\\begin{algorithm}[H]                                % HERE!!!!!!!!!\n        \\caption{显式格式的求解算法}                       % give the algorithm a caption\n    \\label{alg1}                                        % and a label for \\ref{} commands later in the document\n        \\begin{algorithmic}                             % enter the algorithmic environment\n        \\REQUIRE $\\mathbf{u}_{n},p_n,\\mathcal{X}_n$\n        \\STATE 限制算子，由$\\mathbf{u}_n$算出$\\mathbf{U}_n$\n        \\STATE 更新位移$\\mathcal{X}_{n+1}$\n        \\STATE 标准的有限元软件求解$\\mathbf{F}_{n+1}$\n        \\STATE 延拓算子，由$\\mathbf{F}_{n+1}$算出$\\mathbf{f}_{n+1}$\n        \\STATE 不可压NS方程的求解$\\mathbf{u}_{n+1}$和$p_{n+1}$\n        \\end{algorithmic}\n    \\end{algorithm}\n```\n效果：\n\n![image-20221116131246919](https://githubimages.pengfeima.cn/images/202211161312110.png)\n\n参考：https://www.zhihu.com/question/29888730/answer/45945434\n\n## 参考文献\n待续。。。","tags":["latex","beamer","演示稿"]},{"title":"课题组服务器资源分配","path":"/posts/35875/","content":"| d    | IP    | 端口    | 用户名   | 密码   | 机器    |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n|  王彬  | 10.70.181.65 | 7777 | npuheart1 | 710129@heart |  图站一  |\n| 刘友琼 | 10.70.181.65 | 6666 | npuheart0 | 710129@heart |  图站二  |\n| 朱长江 | 10.70.181.65 | 9999 | npuheart9 | 710129@heart |   五万   |\n|  郝玉  | 10.70.181.65 |  22  | npuheart1 | 710129@heart |   聚泰   |\n|  郝玉  | 10.69.46.201 | 2222 |   caili   | 710129@heart |   聚泰   |\n|  钟倩  | 10.70.181.65 |  22  | npuheart  | 710129@heart | 四楼集群 |\n| 马鹏飞 | 10.69.46.201 |  22  |  fenics   | 710129@heart | 四楼图站 |\n|  曹瑾  |              |      |           |              |          |\n|  徐娟  | 10.70.181.65 | 3389 |  lenovo   | 710129@heart |  投影仪  |","tags":["加密"]},{"title":"2022年12月","path":"/posts/63420/","content":"2022年12月2日 星期五 21:18:12&emsp;&emsp;昨天下午，我和王明齐一起走去实验室，路上我们都表达了晚上早点睡的想法。&emsp;&emsp;昨晚，宿舍里就我和王明齐两人，过了12点，王明齐就关了灯。关灯后我也不再玩手机。&emsp;&emsp;第二天早上，我还在睡梦中，王明齐叫醒了我。我醒来的时候才七点半，天很冷，我不想离开被窝，但是我立马意识到，是我自己想早点起床，是我要求人家早上叫我，不管身体上多么不愿意，我都应该做到，不辜负别人，也不辜负自己，过好自己的生活。&emsp;&emsp;今天早上，我们8点前离开了宿舍，去云餐吃了胡辣汤。今天算一个比较好的开始吧。&emsp;&emsp;其实我很清楚，我想要什么样的生活，我也明白，失去了的再也回不来了。我打开forest，我自己一个人也可以种树！ 2022年12月5日 星期一 10:40:00&emsp;&emsp;一个周末，什么也没干。&emsp;&emsp;上周五，王明齐不在，晚上我又很晚才睡。第二天早上没有起床，到了吃晚饭的时候才起床。这天我又在捣鼓我的博客，可以通过微信公众号后台转发我的消息，然后将文本添加到GitHub issue上，将图片和视频上传到github仓库或者七牛云存储，参见这篇博客。周六晚上，我自己一个人在宿舍，晚上四点多才睡。我已经沉迷于某样我不知道是什么，但明白它无意义的东西。&emsp;&emsp;昨天我做了什么事？我也不知道。我不知道自己早上几点起床的。晚上，我在南餐吃饭，在云A楼下买了两个熟透了的硬柿子，去了办公室。在办公室，我又在折腾我的微信，我能够搭建一个微信机器人，但是这又有什么用呢？&emsp;&emsp;今天早上，我在张司辰的电话声中醒来。我在南餐二楼的清真窗口点了一碗胡辣汤，喝完后我就回宿舍了。9点醒来，到现在快十一点了，我还是什么都没干。我在宿舍里，听着张司辰和他的小三在电话里呢喃，他称呼对方老婆，跟对方说\"爱你爱你超爱你\"。而我不想接任何人的电话。&emsp;&emsp;前几天，我去医院看了我的疣，它已经长了不知道多少年了。医生在病历上给我填了两年，然后用液氮冷冻了一下。慢慢地，伤口处肿起来一个水泡。今早，我把我的疣给拔了，血流不止，我跟楼非凡说了这件事。&emsp;&emsp;写到这里感觉心情好了些。心情好了些以后我就要开始干活了。现在是11点钟，我打算12点半去吃午饭，然后回来睡午觉，下午两点前去办公室工作。我要做哪些工作呢？最紧迫的当然是我的中期答辩。我现在已经明确知道，采用投影法求解不可压缩NS方程时，对流项的时间离散格式为$$\\mathbf{u}_{n}\\nabla\\cdot \\mathbf{u}_*,$$如果要通过能量方法证明数值格式的稳定性，那么这一项是没办法消去的。我也不强求这个了。 2022年12月6日 星期一 10:40:00&emsp;&emsp;今天早上到现在什么也没干。 2022年12月8日 星期一 11:52:00&emsp;&emsp;今天早上到现在什么也没干。","tags":["加密"]},{"path":"/about/index.html","content":"最近动态 建站日志 Thu Nov 17 2022 - 现在我的网站差不多能看了🥳 - 研究了一下我在用的Stellar主题，发现wiki功能设计得特别好。 Wen Nov 16 2022 - ICP备案通过了审核，域名是pengfeima.cn - 在GitHub上偶然认识了skyreeves发现他的博客很好看，于是兴致勃勃地想做一个 Mon Nov 14 2022 搭建了GitHub图床，将域名解析服务器更改为cloudflare，白嫖cloudflare的CDN服务，虽然还是有点慢😣但是比直接用GitHub的链接快多了 Mon Nov 07 2022 - 叫妈妈帮忙注册了一个阿里云账号，然后用很优惠的价格购买了一台一年的轻量服务器🥳 - 提交了ICP备案申请，打算搭建个网站 FEniCS 官方FEniCS 第三方教程PT 站博客主题云服务"},{"path":"/index.html","content":"<center><a href=\"https://blog.pengfeima.cn/\">MerryJingle</a>，快乐的铃铛，为毕业发愁中，会点C++和CUDA，研究流固耦合问题</center> 遗忘十字路 遗忘十字路 王国边缘 王国边缘 皇后花园 皇后花园 国王驿站 (一些不是我拍的🤫)今年秋天的照片 瀑布流参考：https://github.com/xaoxuu/hexo-theme-stellar/issues/210<style>.cards { width: 100%; /* max-width: 1040px; */ margin: 0 auto; text-align: center;}.card { overflow: hidden; transition: .3s ease-in-out; border-radius: 4px; background-color: #efefef; padding: 0px;}.cards img { padding: 0; border-radius: 4px;}@media (prefers-color-scheme: dark) { .card {background-color: #333;}}</style><div id=\"mygallery\" > <a href=\"https://githubimages.pengfeima.cn/images/202211291216879.jpg\"> <img alt=\"Title 1\" src=\"https://githubimages.pengfeima.cn/images/202211291216879.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291217546.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217546.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291217893.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217893.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291217240.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217240.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216894.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216894.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291217904.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217904.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291217670.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291217670.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216722.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216722.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a> <a href=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"> <img alt=\"Title 2\" src=\"https://githubimages.pengfeima.cn/images/202211291216662.jpg\"/> </a></div>"},{"title":"朋友圈","path":"/friends/index.html","content":"他们在干什么呀~ Xaoxuu Skyreeves 是非题 星日语 添加友链的方法 第一步：新建 Issue新建GitHub Issue按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：1. 打开压缩图上传自己的头像，将图片尺寸调整到 `96px` 后下载。2. 将压缩后的图片上传到去不图床并使用此图片链接作为头像。 第二步：添加友链并等待管理员审核请添加本站到您的友链中，如果您也使用 issue 作为友链源，只需要告知您的友链源仓库即可。title: MerryJingleavatar: https://avatars.githubusercontent.com/u/115222128url: https://blog.pengfeima.cn/screenshot: https://githubimages.pengfeima.cn/images/202211172254234.pngdescription: 快乐的铃铛待管理员添加 `active` 标签后即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客更新。如果无法修改，可以重新创建一个。"},{"path":"/wiki/multigrid/index.html","content":"## 前言"},{"title":"Hello World","path":"/wiki/multigrid/文章3.html","content":"## 问题描述"},{"title":"站点美化点点滴滴","path":"/wiki/notes/index.html","content":"前言大风的法俄大额jjjjfadfadfafefd学长大啊 这条内容为静态数据这条内容为静态数据，静态数据在 `deploy` 时就已经确定了。```c++// ssint a=0```> vunn> ukhuhhjbjhkbk,n,'[kjnhby] content [color:red]SkyReevesStellar主题自定义侧边栏教程「萌新向」wiki的作用：http://www.example.com/notes/站点美化/文章3.html"},{"title":"Hello Wordfadfadsfald","path":"/wiki/notes/游戏/文章1.html","content":"## 文章1"},{"title":"Hello Wordfadfadsfald","path":"/wiki/notes/站点美化/文章3.html","content":"## 文章1"},{"title":"Hello Wordfadfadsfald","path":"/wiki/notes/游戏/文章2.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\nHHHHHHHaahahaahh\n### Create a new post\n\n``` bash\n$ hexo new \"M .       y New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)"},{"title":"Hello Wordfadfadsfald","path":"/wiki/notes/站点美化/文章4.html","content":"## 文章1"}]